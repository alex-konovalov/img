<?xml version="1.0" encoding="UTF-8"?>

<?LaTeX ExtraPreamble="\usepackage{graphicx}"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd" [
 <!ENTITY see '<Alt Only="LaTeX">$\to$</Alt><Alt Not="LaTeX">--&tgt;</Alt>'>
 <#Include Label="Version">
]>
<Book Name="IMG">

<TitlePage>
  <Title>Iterated monodromy groups</Title>
  <Version>Version &Version;</Version>
  <TitleComment>
    Groups and dynamical systems
  </TitleComment>
  <Author>Laurent Bartholdi
	  <Email><Alt Only="HTML">laurent dot bartholdi at gmail dot com</Alt>
		 <Alt Not="HTML">laurent.bartholdi@gmail.com</Alt></Email>
	  <Homepage>http://www.uni-math.gwdg.de/laurent/</Homepage>
  </Author>
  <Date>&Date;</Date>
  <Address>
  Mathematisches Institut<Br/>Bunsenstraße 3-5<Br/>D-37073 Göttingen<Br/>Germany
  </Address>
  <Abstract>
    This document describes the package <Package>IMG</Package>, which
    implements in &GAP; the iterated monodromy groups of Nekrashevych. It
    depends on the package <Package>FR</Package>.
  <Alt Only="HTML">
  <P/>
  The computer algebra system &GAP; is available at
  <URL>http://gap-system.org</URL>.
  <P/>
  This documentation for <Package>IMG</Package> is available at
  <URL>http://laurentbartholdi.github.com/img/doc/manual.pdf</URL> in PDF
  format, and may be accessed online at
  <URL>http://laurentbartholdi.github.com/img/</URL>.
  <P/>
  The latest release of the package may be downloaded as
  <URL>https://github.com/laurentbartholdi/img/archive/&Version;.tar.gz</URL> (tar, gzipped) and
  <URL>https://github.com/laurentbartholdi/img/archive/&Version;.zip</URL> (zip).
  The latest repository version (possibly unstable) may be downloaded as
  <URL>https://github.com/laurentbartholdi/img/tarball/master</URL> (tar, gzipped),
  <URL>https://github.com/laurentbartholdi/img.git</URL> (git repository), or
  explored at <URL>https://github.com/laurentbartholdi/img/tree/master/</URL>.
  </Alt>
  <P/>
    For comments or questions on <Package>IMG</Package> please contact
    the author; this package is still under development.
  </Abstract>
  <Copyright>&copyright; 2006-2013 by Laurent Bartholdi
  </Copyright>
  <Acknowledgements>Part of this work is/was supported by the
  "German Science Foundation".
  </Acknowledgements>
  <Colophon>
  This project started as a part of the &GAP; package <Package>FR</Package>.
  It expanded so much that I decided in 2012 to split it off, so as to
  keep more cleanly separated the group theory on one side, and the
  complex analysis, on the other side.
  </Colophon>

</TitlePage>

<TableOfContents/>

<Body>

<Chapter><Heading>Licensing</Heading>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or any
later version.

<P/> This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

<P/> You should have received a copy of the GNU General Public
License along with this program, in the file COPYING.  If not, see
<URL>http://www.gnu.org/licenses/</URL>.

</Chapter>

<Chapter Label="imgpackage"><Heading>IMG package</Heading>

<Section Label="mathintro"><Heading>A brief mathematical introduction</Heading>

This chapter assumes that you have no familiarity with iterated
monodromy groups. If you do, and wish to see their usage within &GAP;
through a sample session, please skip to Section <Ref
Label="imgintro"/>.  For a more thourough introduction on self-similar
groups and iterated monodromy groups, see <Cite Key="MR2091700"/> or
<Cite Key="MR2162164"/>.

<P/> Basic knowledge of the package <Package>FR</Package> is assumed,
however. Please refer to its online documentation, or the same
references as above.

<P/> The fundamental objects are <E>Thurston maps</E>: branched
self-coverings of the sphere <M>S^2</M>. These are continuous maps
<M>f:S^2\to S^2</M> that, locally, are modelled on the complex map
<M>z\mapsto z^n</M>. The <E>critical points</E> are those points
<M>z</M> at which the map is modelled on <M>z\mapsto z^n</M> for some
<M>n&gt;1</M>. The <E>post-critical set</E> is the union <M>P</M> of
strictly forward orbits of critical points. It is assumed finite.

<P/> Two Thurston maps <M>f:(S^2,P)\to(S^2,P)</M> and
<M>g:(S^2,Q)\to(S^2,Q)</M> are <E>combinatorially equivalent</E> if
they are isotopic through isotopies <M>(S^2,P)\to(S^2,Q)</M> that are
constant on <M>P</M>.

<P/> Denote by <M>G</M> the fundamental group <M>\pi_1(S^2\setminus
P,*)</M> at a basepoint <M>*</M>. Then combinatorial equivalence
classes of Thurston maps are classified by wreath recursions for
<M>G</M>, namely homomorphisms <M>\phi:G\to G\wr
\mathop{Sym}_d</M>. They are encoded, in <Package>IMG</Package>, by a
new kind of FR machine, called a <E>sphere machine</E>.  Generators of
the machine correspond to loops in the fundamental group of the sphere
(punctured at post-critical points), that circle once
counter-clockwise around a post-critical point.

<P/> By a fundamental theorem of Thurston, every Thurston map (apart
from a few low-complexity examples) is either combinatorially
equivalent to a rational map, or is <E>obstructed</E>: there exists a
system of curves on <M>S^2\setminus P</M> with some appropriate
non-contraction property.

<P/> The operations in this package let one manipulate Thurston maps,
and in particular
<List>
<Item> compute the rational map, or the obstruction, associated with a sphere machine;</Item>
<Item> compute the sphere machine associated with a rational map;</Item>
<Item> construct sphere machines algebraically, and identify their combinatorial parameters, in the case of polynomial maps;</Item>
<Item> compute combinations of sphere machines, such as matings.</Item>
</List>
</Section>

<Section Label="imgintro"><Heading>An example session</Heading>

This is a brief introduction describing some of the simpler features
of the <Package>IMG</Package> package. It assumes you have some
familiarity with the theory of groups defined by automata, and of
holomorphic dynamical systems; if not, a brief mathematical
introduction may be found in Section <Ref Label="mathintro"/>. We show
here and comment a typical use of the package.

<P/> The package is installed by unpacking the archive in the
<File>pkg/</File> directory of your &GAP; installation. It can also be
placed in a local directory, which must be added to the load-path by
invoking <C>gap</C> with the <C>-l</C> option.

<Example><![CDATA[
gap> LoadPackage("img");
true
]]></Example>

Many maps and sphere machines are predefined by the
<Package>IMG</Package>, see Chapter <Ref Label="imgexamples"/>.

<P/> We may start by defining a machine by its polynomial:
<Example><![CDATA[
gap> basilica := PolynomialSphereMachine(2,[1/3]);
<sphere machine with alphabet [ 1 .. 2 ] and adder FRElement(...,f3) on Group( [ f1, f2, f3 ] )/[ f\
3*f2*f1 ]>
gap> Display(basilica);
 G  |      1         2
----+---------+---------+
 f1 | f1^-1,2   f3^-1,1
 f2 |    f1,1    <id>,2
 f3 |    f3,2    <id>,1
----+---------+---------+
Adding element: FRElement(...,f3)
Relators: [ f3*f2*f1 ]
]]></Example>
We have just created the basilica machine, with group <M>G=\langle f1,f2,f3|f3f2f1\rangle</M>.

<P/> ...
</Section>

</Chapter>

<Chapter Label="img"><Heading>Iterated monodromy groups</Heading>
Iterated monodromy machines are a special class of group FR machines
(see Section <Ref Label="FRMachine" BookName="FR"/>) whose underlying
<Ref Oper="StateSet" BookName="FR"/> is a sphere group, namely a group
given by a redundant generator and a relation involving all generators
once.

<Section><Heading>Creators and operations for sphere machines</Heading>
<#Include Label="SphereMachine">
<#Include Label="SphereGroups">
<#Include Label="Thurston">
<#Include Label="PolynomialFRMachine">
<#Include Label="SphereOperations">
<#Include Label="AutomorphismsFRMachines">
<#Include Label="DBRationalIMGGroup">
</Section>

<Section><Heading>Spiders</Heading>
<Package>IMG</Package> contains an implementation of the
Thurston-Hubbard-Schleicher "spider algorithm" <Cite Key="MR1315537"/>
that constructs a rational map from an IMG recursion. This
implementation does not give rigourous results, but relies of
floating-point approximation. In particular, various floating-point
parameters control the proper functioning of the algorithm. They are
stored in a record, <C>EPS@fr</C>. Their meaning and default values
are:<List>
<Mark><C>EPS@fr.mesh := 10^-1</C></Mark> <Item> If points on the unit sphere
  are that close, the triangulation mesh should be refined.</Item>
<Mark><C>EPS@fr.prec := 10^-6</C></Mark> <Item> If points on the unit
  sphere are that close, they are considered equal.</Item>
<Mark><C>EPS@fr.obst := 10^-1</C></Mark> <Item> If points on the unit sphere
  are that close, they are suspected to form a Thurston obstruction.</Item>
<Mark><C>EPS@fr.juliaiter := 10^3</C></Mark> <Item> In computing
  images of the Julia set, never recur deeper than that.</Item>
<Mark><C>EPS@fr.fast := 10^-1</C></Mark> <Item> If the spider moved
  less than that amount in the last iteration, try speeding up by
  only wiggling the spider's legs, without recomputing it.</Item>
<Mark><C>EPS@fr.ratprec := 10^-10</C></Mark> <Item> The desired
  precision on the coefficients of the rational function.</Item>
</List>

.....
(a) there is a concept of "marked sphere". It is made of an N-generated group, a collection of N elements of P^1(C) called "feet", a triangulation of the sphere that includes these elements among its vertices, and a marking of the edges by elements of the group in such a manner that a loop around point i is conjugate to generator i. To keep track of "loops around things", the triangulation also remembers its dual graph.

(b) given a marked sphere and a rational map (given by coefficients), a procedure computes the "lifted marked sphere" and a wreath recursion between their respective groups, i.e. a homomorphism G_{below} \to G_{above} wr sym(d). The procedure will probably fail unless the critical values are close to the feet. There, the algorithm is already subtle: edges of the dual graph are represented by arcs of great circles. One first computes the full preimage of the feet, and a triangulation spanning them on a sphere "above" the original marked sphere. Then, for each edge of the "down" dual graph, its preimage on the "up" sphere is an algebraic curve. One computes its intersections with all edges of the "up" dual graph, by finding zeroes of real polynomials, to determine from which triangle to which one the lifted edges go. Because of rounding errors, one has to be careful as to when a real polynomial is supposed to have a zero, or when a point is supposed to be in a triangle. E.g., if T is a triangle and its sides are given by arcs of great circles, represented as gamma_i([0,1]) for Moebius maps gamma_i, i=1,2,3, then the test "Im(gamma_i(z))&gt;0 forall i" determines whether z is in the triangle. This test is really coded as "Im(gamma_i(z)) / (1+|gamma_i(z)|^2) &gt; -@IMG.p1eps" to take care of rounding errors.

(c) given a marked sphere and a permutation representation of its group, a procedure computes a rational map with that monodromy. If the representation has degree 2, or is bicritical, or a few other cases easily coded by hand, then the rational map is computed algebraically. Otherwise, the "hard" part of the algorithm comes into play. A fresh marked sphere is constructed with only the feet with non-trivial permutation. The triangulation is then combinatorially lifted, using the permutation representation. In particular, the feet are now labeled by cycles of the permutations. It is a purely combinatorial triangulation, at this point; but one remembers that its edges have a length inherited from the sphere metric. The triangulation is then refined by repeatedly adding circumcentres of triangles, till every edge (say from v to w) has length \le @IMG.hurwitzmesh ^ Maximum(cycle length at v, cycle length at w). Now an external C program, "layout", is called. It seeks a discrete conformal map, given by a function u: {feet} \to R, such that if edge e (from v to w) has its length scaled by u(v)*u(w) then the sum-of-angles=2pi condition holds at each vertex (with special treatment for a vertex at infinity; I skip details). Then the triangulation can be laid out on the plane, and projected back stereographically to the sphere. In this manner, we got good approximations of where the feet should be. Now we run Newton's method on the feet positions, using as variables the lifted-feet positions. This is the external program "hsolve". It is assumed that the down-feet contain 0 and infinity, so that the rational map we are looking for is of the form f(z) = const*prod((z-c_i)^{d_i}) for known integers d_i. The c_i are the lifted-feet above 0 and infinity, and the equations in Newton's method say that the log-derivative of f must vanish at appropriate lifted-feet, and that f must map these lifted-feet to the down-feet.

(d) For Thurston's algorithm, one starts by an arbitrary marked sphere (I chose its feet on the real axis, at equal small angles); computes a rational map using (c), computes [*] its biset using (b), and matches the original biset with the lifted one. This tells us which feet of the lifted biset we should keep. One then computes a normalized position for the sub-marked sphere: its last foot is at infinity, another one (chosen cleverly) is on the positive real axis, and the center of mass of all feet (in R^3) is (0,0,0). This is much more stable, numerically, than putting 3 points at 0,1,infty. One has a Moebius transformation that puts the sub-marked sphere in normalized position, and by (b) computes its biset. One then composes the bisets, and compares it again to the original biset to determine the marking of the edges of the new marked sphere by group elements. Then, one searches for all quadruples with large cross-ratio, and computes group-theoretically the curve separating the post-critical set in two parts that are well separated. One saturates the resulting curve into an invariant multicurve (aborting if there is an intersection between lifts), computes the Thurston matrix, and finds out (again algebraically) if there is an eigenvalue \geq 1. There is no parameter in this part of the code, all quadruples are examined; this is a weakness of the current implementation, sometimes most of the computational time is spent on searching for obstructions when it's "clear" there are none. The distance between two marked spheres (marked by the same group) is computed as follows: if their feet are close in the sense that the sum of the spherical distances between them is less that @IMG.fast, then wiggle one of the spiders to make its feet match that of the other; and check that the identity map gives, by (b), the identity biset. In that case, the sum of the feet distances is the distance between the spheres. Otherwise, add to it some formula involving the entries in the biset, which gives large integer distances. The Thurston algorithm stops when an obstruction is found or when the marked sphere moved less than @IMG.ratprec. Inside the main iteration of the algorithm, if the spider moved less that @IMG.fast, then skip step [*], and try guessing which of the lifts should be kept. Check the guess: if it is incorrect, go back to the usual method. This is useful if the biset has low degree but high post-critical set size, and useless if the biset has high degree and low post-critical set size, but I haven't taken care to disable it in that case (yet).

Another speedup which I should implement, but haven't gotten to, is in (c) to remember the previously computed rational map and/or triangulated sphere, and to directly try Newton's method without doing the "layout" part.
.....

<#Include Label="Triangulations">
<#Include Label="MarkedSpheres">
<#Include Label="RotatedSpider">
<#Include Label="Hurwitz">
<#Include Label="Conversions">
</Section>
</Chapter>

<Chapter Label="imgexamples"><Heading>Examples</Heading>
<Package>IMG</Package> predefines a large collection of machines and
groups. The groups are, whenever possible, defined as state closures
of corresponding Mealy machines.

<Section><Heading>Examples of groups</Heading>
<#Include Label="Poirier">
</Section>

</Chapter>

<Chapter><Heading>IMG implementation details</Heading>

<Package>IMG</Package> creates new categories for the various objects
considered in the package. The first category is ...

<Section><Heading>Marked spheres</Heading>
<Package>IMG</Package> contains algorithms that convert a rational
function (with floating-point complex coefficients) to an IMG machine
and back.

<P/> Consider a rational map <M>f</M> of degree <M>d</M>. First, compute the
post-critical set <M>P_f</M>; this is done by iterating <M>f</M> on
critical points, and considering points at angle at
most <M>EPS@.prec</M> from each other as equal.

<P/> Then construct a spherical Delaunay triangulation <M>T</M>
on <M>P_f</M>; and choose in it a minimal spanning tree; edges of that
tree represent a generating set of the fundamental group <M>G</M>
of <M>S^2\setminus P_f</M>.

<P/> Lift first through <M>f</M> the edges of the dual tree in the
dual tesselation of <M>T</M>; they will form <M>d</M> connected
subgraphs, numbered <M>1,\ldots,d</M>. Lift then the edges crossing the
minimal spanning tree, and read the elements of <M>F</M> that their
lifts represent, as well as the subgraphs they start and end in. This
data describes an FR machine.

<P/> Choose then for each vertex in <M>P_f</M> an adjacent face
in <M>T/</M>. This choice defines a generating family of <M>F</M> made
up, for each vertex, of a path in the dual tree starting at a
basepoint, a sequence of edges around a vertex starting at the chosen
face, and a path back in the dual tree. The product, in an appropriate
order, of these generators describes an IMG machine.

<P/> There is an epimorphism from the group <M>G</M>, generated by
these loops around vertices, to <M>F</M>; and this epimorphism becomes
an isomorphism if one adds to <M>G/</M> the relation "product of
generators in an appropriate order". Such a triangulation, with a
given group <M>G</M> and a homomorphism from <M>G</M> to <M>F</M>, is
called a <E>spider</E>.

<P/> The inverse algorithm is quite similar. Consider an IMG
machine <M>M</M>, with stateset <M>G</M>. Start by a "standard" set of
points on the sphere, one per generator of <M>M</M>, and construct a
spider <M>S</M> on them. Find a rational map <M>f</M> with critical
values at the vertices of <M>S</M> and monodromy given by the
activities of <M>M</M>, and lift <M>S</M> to a spider <M>T</M>, marked
by a group <M>H</M>. The lifting gives a homomorphism <M>f^*:G\to H\wr
\mathop{Sym}(d)</M>.

<P/> By appropriately relabeling the alphabet, one can ensure that
this homomorphism coincides with <M>M</M>'s recursion at the first
level. Furthermore, it identifies each vertex <M>v_i</M> of <M>T</M>
either with a vertex <M>w_j</M> of <M>S</M>, if for some <M>g\in G</M>
a state in <M>M</M> of <M>g</M> is a conjugate <M>g_j</M>, while the
corresponding entry of <M>f^*(g)</M> is a conjugate of <M>h_i</M>.

<P/> Construct then a new triangulation <M>S'</M> by keeping only
those vertices of <M>T</M> that were identified, and mapping them by a
Möbius transformation <M>\mu</M> to "standard position". This means
that the barycenter of the points is <M>0\in \mathbb R^3</M>, that the
last point goes to <M>\infty</M>, and that the next-to-last goes
to <M>\mathbb R_+</M>. Letting <M>F</M> denote the group on the
minimal spanning tree of <M>S'</M>, there is a
homomorphism <M>\mu_*:H\to F</M>.

<P/> The decomposition <M>\phi</M> of <M>M</M> then produces a
homomorphism <M>m:G\to F</M> such that <M>\mu_*f^*=m\phi</M>. This
turns <M>S'</M> into a spider on <M>G</M>. Iterate then this process
with <M>S'</M>.

<P/> Either the spiders <M>S</M> converge, and then <M>\mu^{-1}f</M>
is the desired rational function; or there is a Thurston obstruction,
which is a non-contracting multicurve. Seek therefore clusters of
vertices that are very close from each other, and compute the curve
going around them; this defines a conjugacy class
in <M>G</M>. In <M>M</M>, compute the iterated decomposition of this
curve, and its associated transition matrix. If it has spectrum at
least <M>1</M>, return the multicurve as an obstruction; otherwise,
continue.

</Section>

</Chapter>

<Chapter><Heading>Miscellanea</Heading>

<Section><Heading>Complex numbers</Heading>
<#Include Label="complexnumbers">
</Section>

<Section><Heading>P1 points</Heading>
<#Include Label="P1Points">
</Section>

<Section><Heading>Miscellanea</Heading>
<#Include Label="Helpers">
</Section>

<Section><Heading>User settings</Heading>
<ManSection>
  <InfoClass Name="InfoIMG"/>
  <Description>
    This is  an <K>Info</K> class for the package <Package>IMG</Package>.
    The command <C>SetInfoLevel(InfoIMG,1);</C> switches on the printing of
    some information during the computations of certain
    <Package>IMG</Package> functions; in particular all automatic
    conversions between IMG machines and Mealy machines.

    <P/> The command <C>SetInfoLevel(InfoIMG,2);</C> requests a little
    more information, and in particular prints intermediate results in
    potentially long calculations such as...

    <P/> The command <C>SetInfoLevel(InfoIMG,3);</C> ensures that
    <Package>IMG</Package> will print information every few seconds or
    so. This is useful to gain confidence that the program is not
    stuck due to a programming bug by the author of
    <Package>IMG</Package>.
  </Description>
</ManSection>
</Section>

</Chapter>

</Body>

<Bibliography Databases="imgbib.xml"/>
<TheIndex/>

</Book>
