<?xml version="1.0" encoding="UTF-8"?>

<?LaTeX ExtraPreamble="\usepackage{graphicx}"?>

<!DOCTYPE Book SYSTEM "gapdoc.dtd" [
 <!ENTITY see '<Alt Only="LaTeX">$\to$</Alt><Alt Not="LaTeX">--&tgt;</Alt>'>
 <#Include Label="Version">
]>
<Book Name="IMG">

<TitlePage>
  <Title>Iterated monodromy groups</Title>
  <Version>Version &Version;</Version>
  <TitleComment>
    Groups and dynamical systems
  </TitleComment>
  <Author>Laurent Bartholdi
	  <Email><Alt Only="HTML">laurent dot bartholdi at gmail dot com</Alt>
		 <Alt Not="HTML">laurent.bartholdi@gmail.com</Alt></Email>
	  <Homepage>http://www.uni-math.gwdg.de/laurent/</Homepage>
  </Author>
  <Date>&Date;</Date>
  <Address>
  Mathematisches Institut<Br/>Bunsenstraße 3-5<Br/>D-37073 Göttingen<Br/>Germany
  </Address>
  <Abstract>
    This document describes the package <Package>IMG</Package>, which
    implements in &GAP; the iterated monodromy groups of Nekrashevych. It
    depends on the package <Package>FR</Package>.
  <Alt Only="HTML">
  <P/>
  The computer algebra system &GAP; is available at
  <URL>http://gap-system.org</URL>.
  <P/>
  This documentation for <Package>IMG</Package> is available at
  <URL>http://laurentbartholdi.github.com/img/doc/manual.pdf</URL> in PDF
  format, and may be accessed online at
  <URL>http://laurentbartholdi.github.com/img/</URL>.
  <P/>
  The latest release of the package may be downloaded as
  <URL>https://github.com/laurentbartholdi/img/archive/&Version;.tar.gz</URL> (tar, gzipped) and
  <URL>https://github.com/laurentbartholdi/img/archive/&Version;.zip</URL> (zip).
  The latest repository version (possibly unstable) may be downloaded as
  <URL>https://github.com/laurentbartholdi/img/tarball/master</URL> (tar, gzipped),
  <URL>https://github.com/laurentbartholdi/img.git</URL> (git repository), or
  explored at <URL>https://github.com/laurentbartholdi/img/tree/master/</URL>.
  </Alt>
  <P/>
    For comments or questions on <Package>IMG</Package> please contact
    the author; this package is still under development.
  </Abstract>
  <Copyright>&copyright; 2006-2012 by Laurent Bartholdi
  </Copyright>
  <Acknowledgements>Part of this work is/was supported by the
  "German Science Foundation".
  </Acknowledgements>
  <Colophon>
  This project started in the mid-1990s, when, as a PhD student I did
  many calculations with groups generated by automata, and realized
  the similarities between all calculations; it quickly became clear
  that these calculations could be done much better by a computer than
  by a human.

  <P/> The first routines I wrote constructed finite representations
  of the groups considered, so as to get insight from fast
  calculations within &GAP;. The results then had to be proved correct
  within the infinite group under consideration, and this often
  involved guessing appropriate words in the infinite group with a
  given image in the finite quotient.

  <P/> Around 2000, I had developed quite a few routines, which I
  assembled in a &GAP; package, that dealt directly with infinite
  groups. This package was primitive at its core, but was extended
  with various routines as they became useful.

  <P/> I decided in late 2005 to start a new package from scratch,
  that would encorporate as much functionality as possible in a
  uniform manner; that would handle semigroups as well as groups; that
  could be easily extended; and with a complete, understandable
  documentation. I hope I am not too far from these objectives.
  </Colophon>

</TitlePage>

<TableOfContents/>

<Body>

<Chapter><Heading>Licensing</Heading>

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or any
later version.

<P/> This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

<P/> You should have received a copy of the GNU General Public
License along with this program, in the file COPYING.  If not, see
<URL>http://www.gnu.org/licenses/</URL>.

</Chapter>

<Chapter Label="imgpackage"><Heading>IMG package</Heading>

<Section Label="mathintro"><Heading>A brief mathematical introduction</Heading>
This chapter assumes that you have no familiarity with groups
generated by automata. If you do, and wish to see their usage within
&GAP; through a sample session, please skip to Section <Ref
Label="frintro"/>.  For a more thourough introduction on self-similar
groups see <Cite Key="MR2091700"/> or <Cite Key="MR2035113"/>.

<P/>
We shall here be interested in groups <M>G</M> defined by their action
on a regular rooted tree. Let <M>X</M> be a finite set; and let
<M>X^*</M> denote the set of words (free monoid) over <M>X</M>. Then
<M>X^*</M> naturally has the structure of a regular rooted tree: the
root is the empty word, and vertex <M>v \in X^*</M> is connected to
vertex <M>vx</M> for all choices of <M>x \in X</M>. Each vertex except
the root therefore has <M>\#X+1</M> neighbours.

<P/> Let <M>W</M> denote the automorphism group of the graph
<M>X^*</M>. Given <M>a \in W</M>, we may restrict its action to
<M>X \subset X^*</M>, and obtain a permutation <M>\pi_a</M> on
<M>X</M>, called the <E>activity</E> of <M>a</M>. We may also obtain,
for all <M>x\in X</M>, a tree automorphism <M>a_x \in W</M>, called
the <E>state of <M>a</M> at <M>x</M></E>, by the formula
<Display>(v){a_x} = w \quad\textrm{if}\quad (xv)a =  x^{\pi_a}w.</Display>
The data <M>(a_x,\pi_a)</M> determine uniquely the automorphism
<M>a</M>, and any choice of <M>a_x</M> and <M>\pi_a</M> defines a tree
isometry. We therefore have a group isomorphism
<Display>\phi: W \to W\wr \mathop{Sym}(X),</Display>
called the <E>Wreath recursion</E>. The image of <M>\phi</M> is the
permutational wreath product <M>W^X \rtimes \mathop{Sym}(X)</M>.

<P/> The state <M>a_x</M> should be interpreted as the restriction of
the action of <M>a</M> on the subtree <M>xX^*</M>; the automorphism
<M>a</M> is defined by acting first on each of the subtrees of the
form <M>xX^*</M> by its respective state, and then permuting these
subtrees according to <M>\pi_a</M>. The wreath recursion can be
iterated on the states of <M>a</M>, to define states <M>a_v</M> for
any <M>v \in X^*</M>.

<P/> The automorphism <M>a \in W</M> may be represented by a graph, as
follows. There is one vertex for each state <M>a_v</M> of <M>a</M>,
labeled <M>\pi_{a_v}</M>; and for each <M>x \in X</M> there is one
edge from state <M>a_v</M> to state <M>a_{vx}</M>, labeled
<M>x</M>. This graph is nothing but a quotient of the regular rooted
tree <M>X^*</M>, where vertices <M>v</M> and <M>w</M> are identified
if <M>a_v=a_w</M>. Again, this graph, with a choice of initial vertex,
determines uniquely the automorphism <M>a</M>.

<P/> This graph may be conveniently encoded in what is called
a <E>Moore machine</E>: it consists of a set <M>Q</M>, the vertex set
of the graph; an alphabet, <M>X</M>; a `transition'
function <M>\phi:Q\times X\to Q</M>, where <M>\phi(q,x)</M> is the
endpoint of the edge starting at <M>q</M> and labeled <M>x</M>; and a
labeling <M>\pi</M> of <M>X</M> by the symmetric group on <M>X</M>. We
will use the equivalent <E>Mealy machines</E>, given by a `transition'
function <M>\phi:Q\times X\to X\times Q</M>, encoding both <M>\phi</M>
and <M>\pi</M> together.

<P/> Of particular interest are <E>finite-state automorphisms</E>:
these are automorphisms whose Mealy machine has finitely many
states. The product and inverse of finite-state automorphisms is again
finite-state.

<P/> A subgroup <M>G \le W</M> is <E>self-similar</E> if <M>G^\phi
\subset G\wr\mathop{Sym}(X)</M>. This is equivalent to asking,
for every <M>a \in G</M>, that all of its states <M>a_x</M> also
belong to <M>G</M>.

<P/> The following important properties have also been considered. A
subgroup <M>G \le W</M> is <E>level-transitive</E> if its action is
transitive on all the <M>G</M>-subsets <M>X^n</M>. It is <E>weakly
branched</E> if it is level-transitive, and for every <M>v\in X^*</M>
there is a non-trivial <M>a_v\in G</M> that fixes <M>X^* \setminus
vX^*</M>. It is <E>branched</E> if furthermore for each <M>n \in \mathbb
N</M> the group generated by all such <M>a_v</M> for all <M>v</M> of
length <M>n</M> has finite index in <M>G</M>.

<P/> A self-similar finitely generated group <M>G \le W</M> is
<E>contracting</E> if there are constants <M>K,n \in \mathbb N</M> and
<M>\lambda&lt;1</M> such that
<M>|a_v|\le\lambda|a|+K</M> for all <M>a\in G</M> and <M>v\in X^n</M>;
here <M>|a|</M> denotes the minimal number of generators needed to
express <M>a</M>. It then follows that there exists a finite set
<M>N\subset G</M> such that for all <M>a\in G</M>, all but finitely
many of the states of
<M>a</M> belong to <M>N</M>. The minimal such <M>N</M> is called the
<E>nucleus</E> of <M>G</M>. Since the states of elements of the
nucleus are again in the nucleus, we see that the nucleus is naturally
a Mealy machine. By considering all elements of <M>W</M> obtained from
this Mealy machine by choosing all possible initial states, we obtain
a generating set for <M>G</M> made of all states of a single machine;
this is the <E>group generated</E> by the machine.

<P/> In this package, we are mainly interested in self-similar groups
of finite-state automorphisms. The reason is historical: Aleshin <Cite
Key="MR713968"/>, and later Grigorchuk <Cite Key="MR565099"/> and
Gupta and Sidki <Cite Key="MR696534"/> constructed peculiar examples
of groups using self-similar finite-state automorphisms. All these
groups can be defined by drawing a small machine (at most five
vertices) and considering the group that they generate.

<P/> We assumed for simplicity that the elements <M>a</M> were
invertible. Actually, in the definition of Mealy machines it makes
sense to accept arbitrary maps, and not necessarily bijections of
<M>X</M> as a label at each vertex. One may in this way define
peculiar semigroups.
</Section>

<Section Label="frintro"><Heading>An example session</Heading>
This is a brief introduction describing some of the simpler features
of the <Package>FR</Package> package. It assumes you have some
familiarity with the theory of groups defined by automata; if not,
a brief mathematical introduction may be found in Section <Ref
Label="mathintro"/>. We show here and comment a typical use of the
package.

<P/> The package is installed by unpacking the archive in the
<File>pkg/</File> directory of your &GAP; installation. It can also be
placed in a local directory, which must be added to the load-path by
invoking <C>gap</C> with the <C>-l</C> option.

<Example><![CDATA[
gap> LoadPackage("fr");
----------------------------------------------------------------
Loading FR 0.857142p5 (Functionally recursive and automata groups)
by Laurent Bartholdi (http://www.uni-math.gwdg.de/laurent)
----------------------------------------------------------------
true
]]></Example>

Many FR groups are predefined by <Package>FR</Package>, see Chapter <Ref
Label="frexamples"/>. We consider here the <E>Basilica group</E>,
considered in <Cite Key="MR1902367"/> and <Cite Key="MR2176547"/>.

<P/> We may start by defining a group: it has two generators <M>a</M>
and <M>b</M>, satisfying the specified recursions.
<Example><![CDATA[
gap> B := FRGroup("a=<1,b>(1,2)","b=<1,a>",IsFRMealyElement);
<self-similar group over [ 1 .. 2 ] with 2 generators>
gap> AssignGeneratorVariables(B);
#I  Assigned the global variables [ a, b ]
]]></Example>
We have just created the group <M>B=\langle a,b\rangle</M>.

<P/> Note that this group is predefined as <C>BasilicaGroup</C>. We now
compute the decompositions of the generators:
<Example><![CDATA[
gap> DecompositionOfFRElement(a); DecompositionOfFRElement(b);
[ [ <2|identity ...>, <2|b> ], [ 2, 1 ] ]
[ [ <2|identity ...>, <2|a> ], [ 1, 2 ] ]
]]></Example>
Elements are described as words in the generators; they are printed as
<C><![CDATA[<2|a>]]></C>, where the <M>2</M> reminds of the degree of
the tree on which <M>a</M> acts.

<P/> The optional argument <Ref Filt="IsFRElement"/> tells
<Package>FR</Package> to store elements in this way. This
representation is always possible, but it is usually inefficient for
calculations. The argument <Ref Filt="IsMealyElement"/> forces
<Package>FR</Package> to use a more efficient representation, which in
some cases may take an infinite time to set up. With no extra
argument, <Package>FR</Package> does what it thinks is best. The
advantages of both representations are sometimes obtained by the
argument <Ref Filt="IsFRMealyElement"/>, which stores both
representations.

<P/> Elements act on sequences over <M>\{1,2\}</M>. The action is
computed in the standard manner:
<Example><![CDATA[
gap> 1^a; [1]^a; [1,1]^a;
2
[ 2 ]
[ 2, 1 ]
]]></Example>
Periodic sequences are also implemented in <Package>FR</Package>; they
are constructed by giving the period and preperiod. The period is
printed by preceding it with a "/":
<Example><![CDATA[
gap> v := PeriodicList([1],[2]);
[ 1, / 2 ]
gap> v^a; v^(a^2);
[/ 2 ]
[/ 1, 2 ]
gap> last{[1..10]};
[ 1, 2, 1, 2, 1, 2, 1, 2, 1, 2 ]
]]></Example>

<P/> Most computations are much more efficient if <M>B</M>'s elements
are converted to <E>Mealy representation</E>,
<Example><![CDATA[
gap> Bm := Image(IsomorphismMealyGroup(B));
<recursive group over [ 1 .. 2 ] with 2 generators>
gap> a := Bm.1; b := Bm.2;
<Mealy element on alphabet [ 1, 2 ] with 3 states>
<Mealy element on alphabet [ 1, 2 ] with 3 states>
]]></Example>
This could have been done automatically by specifying
<C>IsMealyElement</C> as last argument in the call to <C>FRGroup</C>.

<P/> The group <M>B</M> is torsion-free, and its elements are bounded
automata. Although torsion-freeness is difficult to check for
<Package>FR</Package>, it can be checked on individual elements:
<Example><![CDATA[
gap> IsBoundedFRSemigroup(Bm);
true
gap> Order(a); Order(b);
infinity
infinity
gap> g := PseudoRandom(B);; Length(InitialState(g));
4679
gap> Order(g); time;
infinity
2599
]]></Example>

<P/> The group <M>B</M> is weakly branched; more precisely, the
derived subgroup <M>B'</M> contains <M>B' \times B'</M>. To prove
that, it suffices to check <M>[a,b] \times 1\in B'</M> and
<M>1 \times [a,b]\in B'</M>. These elements are constructed using
<Ref Oper="VertexElement"/>:
<Example><![CDATA[
gap> c := Comm(a,b);
<Mealy element on alphabet [ 1, 2 ] with 9 states>
gap> K := NormalClosure(Bm,Group(c));
<self-similar group over [ 1 .. 2 ] with 3 generators>
gap> VertexElement(1,c) in K; VertexElement(1,c) in K;
true
true
gap> DecompositionOfFRElement(VertexElement(1,c))=[[c,One(Bm)],[1,2]];
true
gap> VertexElement(2,c)=Comm(b,a^2);
true
]]></Example>
Note that we had to guess the form of the element
<C>VertexElement(2,c)</C> above. This could have been found out by
&GAP; using <Ref Func="ShortGroupWordInSet"/>.

<P/> We may also check the relations <M>[b^p,(b^p)^{a^p}]=1</M> and
<M>[a^{2p},(a^{2p})^{b^p}]</M> for <M>p</M> any power of <M>2</M>:
<Example><![CDATA[
gap> ForAll([0..10],i->IsOne(Comm(b^(2^i),(b^(2^i))^((a^(2^i)))))); time;
true
1361
]]></Example>

Since the group <M>B</M> is bounded, it is contracting. We compute
its nucleus:
<Example><![CDATA[
gap> NucleusOfFRSemigroup(B);
[ <2|identity ...>, <2|b>, <2|b^-1>, <2|a>, <2|a^-1>, <2|b^-1*a>, <2|a^-1*b> ]
]]></Example>

We then compute the Mealy machine with stateset this nucleus, and draw
it graphically (this requires the external programs
<Package>graphviz</Package> and <Package>imagemagick</Package>):

<Example><![CDATA[
gap> N := NucleusMachine(B);
<Mealy machine on alphabet [ 1, 2 ] with 7 states>
gap> Draw(N);
]]></Example>

We may also draw powers of the dual automaton: these are
approximations to the Schreier graph of <M>B</M>. However, we also
construct a smaller Mealy machine with states only <M>a</M> and
<M>b</M>, which give better images:

<Example><![CDATA[
gap> Draw(DualMachine(N)^3);
gap> M := AsMealyMachine(FRMachine(a))[1];
<Mealy machine on alphabet [ 1, 2 ] with 3 states>
gap> Draw(DualMachine(M)^4);
]]></Example>

These Schreier graphs are orbits of the group; they can be displayed
as follows:

<Example><![CDATA[
gap> WordGrowth(B:point:=[1,1,1,1],draw);
]]></Example>

More properties of <M>B</M> can be checked, or experimented with, on
its finite quotients obtained by truncating the tree on which <M>B</M>
acts at a given length. <C>PermGroup(B,n)</C> constructs a permutation
group which is the natural quotient of <M>B</M> acting on <M>2^n</M>
points:
<Example><![CDATA[
gap> G := PermGroup(B,7);
<permutation group with 2 generators>
gap> Size(G); LogInt(last,2);
309485009821345068724781056
88
]]></Example>

We may "guess" the structure of the Lie algebra of <M>B</M> by
examining the ranks of the successive quotients along its Jennings
series:

<Example><![CDATA[
gap> J := JenningsLieAlgebra(G); time;
<Lie algebra of dimension 88 over GF(2)>
18035
gap> List([1..15],i->Dimension(Grading(J).hom_components(i)));
[ 2, 3, 1, 4, 1, 2, 1, 4, 1, 2, 1, 3, 1, 2, 1 ]
]]></Example>

The "<M>4</M>" in position <M>8</M> of that list should really be a
"<M>5</M>"; computations on finite quotients of <M>B</M> usually give
lower bounds for invariants of <M>B</M>. In that case, we guess that
the ranks behave like a "ruler" function, i.e. that the rank of the
homogeneous component of degree <M>i</M> is <M>2+\nu_2(i)</M> if
<M>i</M> is a power of <M>2</M> and is <M>1+\nu_2(i)</M> otherwise;
here <M>\nu_2(i)</M> is the number of times <M>2</M> divides <M>i</M>.

</Section>

</Chapter>

<Chapter Label="img"><Heading>Iterated monodromy groups</Heading>
Iterated monodromy machines are a special class of group FR machines
(see Section <Ref Label="frmachines"/>) with attribute <Ref
Oper="IMGRelator"/>. This attribute records a cyclic ordering of the
generators of the machine whose product is trivial.

<P/> The interpretation is the following: the machine encodes a
<E>Thurston map</E>, i.e. a post-critically finite topological
branched self-covering of the sphere <M>S^2</M>. Generators of the
machine correspond to loops in the fundamental group of the sphere
(punctured at post-critical points), that circle once
counter-clockwise around a post-critical point. For more details on
the connection between self-similar groups and Thurston maps, see
<Cite Key="MR2162164"/>.

<P/> IMG elements are a bit different from group FR elements: while
we said a group FR element is trivial if and only if its action on
sequences is trivial, we say that an IMG element <M>g</M> is
trivial if there exists an integer <M>N</M> such that unfolding
<M>N</M> times the recursion for <M>g</M> yields only trivial states
(as elements of the underlying free group).

<Section><Heading>Creators and operations for IMG machines</Heading>
<#Include Label="IMGMachine">
<#Include Label="PolynomialFRMachine">
<#Include Label="IMGOperations">
<#Include Label="AutomorphismsFRMachines">
<#Include Label="DBRationalIMGGroup">
</Section>

<Section><Heading>Spiders</Heading>
<Package>FR</Package> contains an implementation of the
Thurston-Hubbard-Schleicher "spider algorithm" <Cite Key="MR1315537"/>
that constructs a rational map from an IMG recursion. This
implementation does not give rigourous results, but relies of
floating-point approximation. In particular, various floating-point
parameters control the proper functioning of the algorithm. They are
stored in a record, <C>EPS@fr</C>. Their meaning and default values
are:<List>
<Mark><C>EPS@fr.mesh := 10^-1</C></Mark> <Item> If points on the unit sphere
  are that close, the triangulation mesh should be refined.</Item>
<Mark><C>EPS@fr.prec := 10^-6</C></Mark> <Item> If points on the unit
  sphere are that close, they are considered equal.</Item>
<Mark><C>EPS@fr.obst := 10^-1</C></Mark> <Item> If points on the unit sphere
  are that close, they are suspected to form a Thurston obstruction.</Item>
<Mark><C>EPS@fr.juliaiter := 10^3</C></Mark> <Item> In computing
  images of the Julia set, never recur deeper than that.</Item>
<Mark><C>EPS@fr.fast := 10^-1</C></Mark> <Item> If the spider moved
  less than that amount in the last iteration, try speeding up by
  only wiggling the spider's legs, without recomputing it.</Item>
<Mark><C>EPS@fr.ratprec := 10^-10</C></Mark> <Item> The desired
  precision on the coefficients of the rational function.</Item>
</List>

<#Include Label="Triangulations">
<#Include Label="MarkedSpheres">
<#Include Label="Hurwitz">
<#Include Label="Conversions">

<#Include Label="ChangeFRMachineBasis">
</Section>
</Chapter>

<Chapter Label="imgexamples"><Heading>Examples</Heading>
<Package>IMG</Package> predefines a large collection of machines and
groups. The groups are, whenever possible, defined as state closures
of corresponding Mealy machines.

<Section><Heading>Examples of groups</Heading>
<#Include Label="Poirier">
</Section>

</Chapter>

<Chapter><Heading>IMG implementation details</Heading>

<Package>IMG</Package> creates new categories for the various objects
considered in the package. The first category is ...

<Section><Heading>Marked spheres</Heading>
<Package>FR</Package> contains algorithms that convert a rational
function (with floating-point complex coefficients) to an IMG machine
and back.

<P/> Consider a rational map <M>f</M> of degree <M>d</M>. First, compute the
post-critical set <M>P_f</M>; this is done by iterating <M>f</M> on
critical points, and considering points at angle at
most <M>EPS@.prec</M> from each other as equal.

<P/> Then construct a spherical Delaunay triangulation <M>T</M>
on <M>P_f</M>; and choose in it a minimal spanning tree; edges of that
tree represent a generating set of the fundamental group <M>G</M>
of <M>S^2\setminus P_f</M>.

<P/> Lift first through <M>f</M> the edges of the dual tree in the
dual tesselation of <M>T</M>; they will form <M>d</M> connected
subgraphs, numbered <M>1,\ldots,d</M>. Lift then the edges crossing the
minimal spanning tree, and read the elements of <M>F</M> that their
lifts represent, as well as the subgraphs they start and end in. This
data describes an FR machine.

<P/> Choose then for each vertex in <M>P_f</M> an adjacent face
in <M>T/</M>. This choice defines a generating family of <M>F</M> made
up, for each vertex, of a path in the dual tree starting at a
basepoint, a sequence of edges around a vertex starting at the chosen
face, and a path back in the dual tree. The product, in an appropriate
order, of these generators describes an IMG machine.

<P/> There is an epimorphism from the group <M>G</M>, generated by
these loops around vertices, to <M>F</M>; and this epimorphism becomes
an isomorphism if one adds to <M>G/</M> the relation "product of
generators in an appropriate order". Such a triangulation, with a
given group <M>G</M> and a homomorphism from <M>G</M> to <M>F</M>, is
called a <E>spider</E>.

<P/> The inverse algorithm is quite similar. Consider an IMG
machine <M>M</M>, with stateset <M>G</M>. Start by a "standard" set of
points on the sphere, one per generator of <M>M</M>, and construct a
spider <M>S</M> on them. Find a rational map <M>f</M> with critical
values at the vertices of <M>S</M> and monodromy given by the
activities of <M>M</M>, and lift <M>S</M> to a spider <M>T</M>, marked
by a group <M>H</M>. The lifting gives a homomorphism <M>f^*:G\to H\wr
\mathop{Sym}(d)</M>.

<P/> By appropriately relabeling the alphabet, one can ensure that
this homomorphism coincides with <M>M</M>'s recursion at the first
level. Furthermore, it identifies each vertex <M>v_i</M> of <M>T</M>
either with a vertex <M>w_j</M> of <M>S</M>, if for some <M>g\in G</M>
a state in <M>M</M> of <M>g</M> is a conjugate <M>g_j</M>, while the
corresponding entry of <M>f^*(g)</M> is a conjugate of <M>h_i</M>.

<P/> Construct then a new triangulation <M>S'</M> by keeping only
those vertices of <M>T</M> that were identified, and mapping them by a
Möbius transformation <M>\mu</M> to "standard position". This means
that the barycenter of the points is <M>0\in \mathbb R^3</M>, that the
last point goes to <M>\infty</M>, and that the next-to-last goes
to <M>\mathbb R_+</M>. Letting <M>F</M> denote the group on the
minimal spanning tree of <M>S'</M>, there is a
homomorphism <M>\mu_*:H\to F</M>.

<P/> The decomposition <M>\phi</M> of <M>M</M> then produces a
homomorphism <M>m:G\to F</M> such that <M>\mu_*f^*=m\phi</M>. This
turns <M>S'</M> into a spider on <M>G</M>. Iterate then this process
with <M>S'</M>.

<P/> Either the spiders <M>S</M> converge, and then <M>\mu^{-1}f</M>
is the desired rational function; or there is a Thurston obstruction,
which is a non-contracting multicurve. Seek therefore clusters of
vertices that are very close from each other, and compute the curve
going around them; this defines a conjugacy class
in <M>G</M>. In <M>M</M>, compute the iterated decomposition of this
curve, and its associated transition matrix. If it has spectrum at
least <M>1</M>, return the multicurve as an obstruction; otherwise,
continue.

</Section>

</Chapter>

<Chapter><Heading>Miscellanea</Heading>

<Section><Heading>Complex numbers</Heading>
<#Include Label="complexnumbers">
</Section>

<Section><Heading>P1 points</Heading>
<#Include Label="P1Points">
</Section>

<Section><Heading>Miscellanea</Heading>
</Section>

<Section><Heading>User settings</Heading>
<ManSection>
  <InfoClass Name="InfoIMG"/>
  <Description>
    This is  an <K>Info</K> class for the package <Package>IMG</Package>.
    The command <C>SetInfoLevel(InfoIMG,1);</C> switches on the printing of
    some information during the computations of certain
    <Package>IMG</Package> functions; in particular all automatic
    conversions between IMG machines and Mealy machines.

    <P/> The command <C>SetInfoLevel(InfoIMG,2);</C> requests a little
    more information, and in particular prints intermediate results in
    potentially long calculations such as...

    <P/> The command <C>SetInfoLevel(InfoIMG,3);</C> ensures that
    <Package>IMG</Package> will print information every few seconds or
    so. This is useful to gain confidence that the program is not
    stuck due to a programming bug by the author of
    <Package>IMG</Package>.
  </Description>
</ManSection>
</Section>

</Chapter>

</Body>

<Bibliography Databases="imgbib.xml"/>
<TheIndex/>

</Book>
