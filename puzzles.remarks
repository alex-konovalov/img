
 The code about puzzles  that I wrote so far is in the attached file.
 So far the program does not do a lot..., but what it can do or may do is the following:

1) Puzzles_Fr(machine)    creates list of  "puzzle system" of level 0;
so far puzzles are of the following form:

#   return rec(
#      machine := machine,
#      group0 := group0,           a free group of rank n
#      group1 := group1,           a free group of rank m>n
#      embedding := embedding,     a surjective homomorphism from group0 to group1
#      covering := cover,          a covering homomorphism from group1 to group0
#      homomorphism := hom,        a homeomorphism from group0 to StateSet(machine)
#      globallevel := 0,
#      levels := List([1..Length(GeneratorsOfGroup(group0))], i->[0]),    list of levels of "puzzle pieces"
#      refinest := false,
#      coordinate0 :=coordinate0,     describe cyclic ordering of puzzle piece's sides
#      coordinate1 := coordinate1     describe cyclic ordering of puzzle piece's sides
#   );

#  some properties:
# embedding("cyclic product of generators") = "cyclic product of generators"
# embedding(covering( "cyclic product of generators" )) = "cyclic product of generators"^degree;

# for any f in group0
# homomorphism(f) is a pre-image of homomorphism(embedding(covering(f)))

# convention: if a is a pullback of b under  puzzle.covering,
# then  puzzle.covering(a) =   (b^"degree")^(n*"cyclic product of generators")
# and n is minimal

the last two fields (coordinate0 ,coordinate1) are useless in the current version.


2) PuzzlePullback_Fr(puzzle) takes one pullback of puzzle system;
currently it has a mistake, but it is possible to fix. Usually it works, and in the end the function verifies the result and if it is not correct returns "fail";

Remark: if a piece contains only one post-critical point, then the function does not subdivide this puzzle piece. Therefore the number of puzzle pieces
(or the number of generators of group1)  is bounded by degree*#(post-critical set)

3)IsRefinest_Fr := function(puzzle)   check if a puzzle syztem is "refinest"

4)PuzzleRenormalization_Fr := function(puzzle) so far it is the only useless application of the code.
  # if puzzle.refinest = true, then
  # return a homomorphism that renormalize puzzle.machine

5) CreateIMGMachineFromPuzzle_Fr     does not work mostly,
one of the purposes of writing the code was to for any given puzzle system try to find the minimal (or one of the minimal)
polynomials that satisfy this puzzle piece. kind of 'approximate" the initial polynomial by "smaller" polynomials. I tried several approaches,
it does not seems to work mostly. (unicritical case is easy).


And as I was saying it may be possible to check whether one polynomial is smaller than another. But I did not try to implement that.

I guess I will continue working on this code later.

Dima






