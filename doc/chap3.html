<?xml version="1.0" encoding="UTF-8"?>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
         "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<title>GAP (IMG) - Chapter 3: Iterated monodromy groups</title>
<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
<meta name="generator" content="GAPDoc2HTML" />
<link rel="stylesheet" type="text/css" href="manual.css" />
<script src="manual.js" type="text/javascript"></script>
<script type="text/javascript">overwriteStyle();</script>
</head>
<body class="chap3"  onload="jscontent()">


<div class="chlinktop"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<div class="chlinkprevnexttop">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>

<p><a id="X798DE1297EC58F59" name="X798DE1297EC58F59"></a></p>
<div class="ChapSects"><a href="chap3.html#X798DE1297EC58F59">3 <span class="Heading">Iterated monodromy groups</span></a>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X86CEB5F38312582E">3.1 <span class="Heading">Creators and operations for sphere machines</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A327CA47E574383">3.1-1 IsSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86CAE06C7EBAFB00">3.1-2 AsSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81BA485A7B053B80">3.1-3 CleanedSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B17531E7B058369">3.1-4 NewSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X834FE6AC798A520F">3.1-5 IsSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87E99FEC8598B845">3.1-6 IsomorphismSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8307F8DB85F145AE">3.1-7 EulerCharacteristic</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81B9BA1586981067">3.1-8 RankOfSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X79A08D5C8532F976">3.1-9 OrderingOfSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7D973ED3816A1CBD">3.1-10 ExponentsOfSphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7ECF53F97DC06E4C">3.1-11 IsomorphismFreeGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7DBBD32080770BD7">3.1-12 SphereGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8120094A7BFA9C48">3.1-13 IsSphereConjugacyClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8123456781234567">3.1-14 </a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X867DE11A7E9E02E7">3.1-15 PeripheralClasses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X822BA8867B084B6C">3.1-16 IntersectionNumber</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X87677B0787B4461A">3.1-17 AutomorphismGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A205FFD86D128B9">3.1-18 AmalgamateFreeProduct</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8283D95B7FE74991">3.1-19 NormalizedP1Map</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E423D047DB95301">3.1-20 ThurstonAlgorithm</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A6170147F1376F2">3.1-21 P1MapBySphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X807FAD4982B21B2A">3.1-22 ThurstonMatrix</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X787168378397C957">3.1-23 ThurstonObstruction</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84C2881D87C1FB74">3.1-24 IsKneadingMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82F34D5387FF4E57">3.1-25 AddingElement</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BE171B879357604">3.1-26 AsPolynomialSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80E689F38412EE20">3.1-27 PolynomialSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X814E27317A6213D3">3.1-28 SupportingRays</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7EE9C721802D481B">3.1-29 NormalizedPolynomialSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81B7D47D81212C4F">3.1-30 SimplifiedSphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AB029AE8590964E">3.1-31 Mating</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8410869F8358A1AF">3.1-32 AutomorphismVirtualEndomorphism</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82F0B23486F2E3AC">3.1-33 DBRationalIMGGroup</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8365719F7E03B7C3">3.1-34 PostCriticalMachine</a></span>
</div></div>
<div class="ContSect"><span class="tocline"><span class="nocss">&nbsp;</span><a href="chap3.html#X7C73C74D87428A33">3.2 <span class="Heading">Spiders</span></a>
</span>
<div class="ContSSBlock">
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X81727B8B7A599605">3.2-1 IsSphereTriangulation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X833BA8217E601451">3.2-2 EdgePath</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X80C530E87B7FA7C4">3.2-3 DelaunayTriangulation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X82EB5B207B2C273E">3.2-4 AddToTriangulation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7A92BCE987775667">3.2-5 RemoveFromTriangulation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X866712E5799237C6">3.2-6 LocateFaceInTriangulation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7FA533EF78FF292B">3.2-7 WiggledTriangulation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X852EDAD3787E522D">3.2-8 EquidistributedP1Points</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BCBD3A47B95CB12">3.2-9 IsMarkedSphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X859AFCB184D66E76">3.2-10 NewMarkedSphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8563CADF7AA37AA4">3.2-11 Draw</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7B3ACCDC81180337">3.2-12 WiggledMarkedSphere</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7F86A9607DBDD8A9">3.2-13 SphereMachineOfBranchedCovering</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E3708BD7AFB94A4">3.2-14 MonodromyOfP1Map</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X801927327E45A69D">3.2-15 SphereMachine</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X860A9B5E7BC8640D">3.2-16 DistanceMarkedSpheres</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X8692875A793FB66F">3.2-17 LiftOfConjugacyClass</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7BE001A0811CD599">3.2-18 ComplexConjugate</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7E941D2185A1DF3B">3.2-19 RotatedSpider</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X7AEA7BA67950292B">3.2-20 BranchedCoveringByMonodromy</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84FC673C7B104194">3.2-21 DessinByPermutations</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86C9E1938159FEE1">3.2-22 KneadingSequence</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X857FCD7678B12A0C">3.2-23 AllInternalAddresses</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X86C250907E09F399">3.2-24 ExternalAnglesRelation</a></span>
<span class="ContSS"><br /><span class="nocss">&nbsp;&nbsp;</span><a href="chap3.html#X84F962AF7D553DDA">3.2-25 ExternalAngle</a></span>
</div></div>
</div>

<h3>3 <span class="Heading">Iterated monodromy groups</span></h3>

<p>Iterated monodromy machines are a special class of group FR machines (see Section <a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X80D310EF7FD5EA44"><span class="RefLink">FR: FRMachineNC (family,free,listlist,list)</span></a>) whose underlying <code class="func">StateSet</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X8000470D7DA7FFBD"><span class="RefLink">FR: StateSet (FR machine)</span></a>) is a sphere group, namely a group given by a redundant generator and a relation involving all generators once.</p>

<p><a id="X86CEB5F38312582E" name="X86CEB5F38312582E"></a></p>

<h4>3.1 <span class="Heading">Creators and operations for sphere machines</span></h4>

<p>DeclareProperty("IsSphereMachine", IsFRMachine);</p>

<p><a id="X7A327CA47E574383" name="X7A327CA47E574383"></a></p>

<h5>3.1-1 IsSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPolynomialSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( filter )</td></tr></table></div>
<p>The categories of <em>Sphere</em> and <em>polynomial</em> machines. Sphere machines are group FR machines whose underlying group is a sphere group, see <code class="func">SphereGroup</code> (<a href="chap3.html#X7DBBD32080770BD7"><span class="RefLink">3.1-12</span></a>).</p>

<p>A polynomial machine is a group FR machine with a distinguished state (which must be a generator of the stateset), stored as the attribute <code class="func">AddingElement</code> (<a href="chap3.html#X82F34D5387FF4E57"><span class="RefLink">3.1-25</span></a>); see <code class="func">AsPolynomialSphereMachine</code> (<a href="chap3.html#X7BE171B879357604"><span class="RefLink">3.1-26</span></a>). If it is normalized, in the sense that the wreath recursion of the adding element <code class="code">a</code> is <code class="code">[[a,1,...,1],[d,1,...,d-1]]</code>, then the basepoint is assumed to be at <span class="SimpleMath">+∞</span>; the element <code class="code">a</code> describes a clockwise loop around infinity; the <span class="SimpleMath">k</span>th preimage of the basepoint is at <span class="SimpleMath">exp(2iπ(k-1)/d)∞</span>, for <span class="SimpleMath">k=1,dots,d</span>; and there is a direct connection from basepoint <span class="SimpleMath">k</span> to <span class="SimpleMath">k+1</span> for all <span class="SimpleMath">k=1,dots,d-1</span>.</p>

<p>The last category is the intersection of the first two.</p>

<p>DeclareAttribute("AsSphereMachine", IsFRMachine); DeclareOperation("AsSphereMachine", [IsFRMachine, IsWord]); DeclareOperation("AsSphereMachine", [IsFRMachine, IsSphereGroup]);</p>

<p><a id="X86CAE06C7EBAFB00" name="X86CAE06C7EBAFB00"></a></p>

<h5>3.1-2 AsSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSphereMachine</code>( <var class="Arg">m</var>[, <var class="Arg">w</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere machine.</p>

<p>This function creates a new sphere machine, starting from a group FR machine <var class="Arg">m</var>. If a state <var class="Arg">w</var> is specified, and that state defines the trivial FR element, then it is used as relator; if <var class="Arg">w</var> is a sphere group, then it is used as the new stateset. Finally, if no relator and no group is specified, and the product (in some ordering) of the generators is trivial, then that product is used as relator. In other cases, the method returns <code class="keyw">fail</code>.</p>

<p>A standard FR machine can be recovered from a sphere machine by <code class="func">AsGroupFRMachine</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X7BF186227C0ABE8D"><span class="RefLink">FR: AsGroupFRMachine</span></a>), <code class="func">AsMonoidFRMachine</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X7BF186227C0ABE8D"><span class="RefLink">FR: AsMonoidFRMachine</span></a>), and <code class="func">AsSemigroupFRMachine</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap3.html#X7BF186227C0ABE8D"><span class="RefLink">FR: AsSemigroupFRMachine</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := UnderlyingFRMachine(BasilicaGroup);</span>
&lt;Mealy machine on alphabet [ 1 .. 2 ] with 3 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := AsGroupFRMachine(m);</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AsSphereMachine(g,Product(GeneratorsOfFRMachine(g)));</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2, t ] )/[ f1*f2*t ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |              1         2
----+-----------------+---------+
 f1 |          &lt;id&gt;,2      f2,1
 f2 |          &lt;id&gt;,1      f1,2
  t | f2^-1*f1*f2*t,2   f1^-1,1
----+-----------------+---------+
Relator: f1*f2*t
</pre></div>

<p>DeclareAttribute("CleanedSphereMachine",IsSphereMachine);</p>

<p><a id="X81BA485A7B053B80" name="X81BA485A7B053B80"></a></p>

<h5>3.1-3 CleanedSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; CleanedSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A cleaned-up version of <var class="Arg">m</var>.</p>

<p>This command attempts to shorten the length of the transitions in <var class="Arg">m</var>, and ensure (if possible) that the product along every cycle of the states of a generator is a conjugate of a generator. It returns the new machine.</p>

<p>DeclareGlobalFunction("NewSphereMachine");</p>

<p><a id="X7B17531E7B058369" name="X7B17531E7B058369"></a></p>

<h5>3.1-4 NewSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NewSphereMachine</code>( <var class="Arg">...</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A new sphere machine, based on string descriptions.</p>

<p>This command constructs a new sphere machine, in a format similar to <code class="func">FRGroup</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap7.html#X7AE8F92383272329"><span class="RefLink">FR: FRGroup</span></a>); namely, the arguments are strings of the form "gen=&lt;word-1,...,word-d&gt;perm"; each <code class="code">word-i</code> is a word in the generators; and <code class="code">perm</code> is a transformation, either written in disjoint cycle or in images notation. The underlying group of the machine is a sphere group.</p>

<p><code class="code">word-i</code> is allowed to be the empty string; and the "&lt;...&gt;" may be skipped altogether. Each <code class="code">word-i</code> may also contain inverses.</p>

<p>The extra final arguments describe relations in the underlying sphere group; at least one relation is required, the product of the generators in an appropriate order.</p>

<p>The following examples construct realizable foldings of the polynomial <span class="SimpleMath">z^3+i</span>, following Cui's arguments.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fold1 := NewSphereMachine("a=&lt;,,b,,,B&gt;(1,2,3)(4,5,6)","b=&lt;,,b*a/b,,,B*A/B&gt;",</span>
     "A=&lt;,,b*a,,,B*A&gt;(3,6)","B=(1,6,5,4,3,2)","a*B*A*b");
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">&lt;FR machine with alphabet [ 1, 2, 3, 4, 5, 6 ] on Group( [ a, b, A, B ] )/[ a*B*A*b ]&gt;                                </span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">fold2 := NewSphereMachine("a=&lt;,,b,,,B&gt;(1,2,3)(4,5,6)","b=&lt;,,b*a/b,,,B*A/B&gt;",</span>
     "A=(1,6)(2,5)(3,4)","B=&lt;B*A,,,b*a,,&gt;(1,4)(2,6)(3,5)","a*B*A*b");;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RationalFunction(fold1); RationalFunction(fold2);</span>
...
</pre></div>

<p>DeclareProperty("IsSphereGroup", IsFpGroup); DeclareCategory("IsElementOfSphereGroup", IsElementOfFpGroup and IsAssocWord); DeclareCategoryCollections("IsElementOfSphereGroup"); DeclareCategoryCollections("IsElementOfSphereGroupCollection"); DeclareProperty("IsElementOfSphereGroupFamily", IsElementOfFpGroupFamily); DeclareOperation("ElementOfSphereGroup", [IsFamily, IsAssocWordWithInverse]);</p>

<p><a id="X834FE6AC798A520F" name="X834FE6AC798A520F"></a></p>

<h5>3.1-5 IsSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereGroup</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>A sphere group is a special kind of finitely presented group, in which exactly one relation is a product, in some order, of all the generators, and all the other relations (possibly none) are powers of generators.</p>

<p>Sphere groups are used to represent the fundamental groups of punctured spheres, or more generally orbifolds whose underlying space is a sphere.</p>

<p>DeclareAttribute("IsomorphismSphereGroup", IsFpGroup); DeclareAttribute("AsSphereGroup", IsFpGroup);</p>

<p><a id="X87E99FEC8598B845" name="X87E99FEC8598B845"></a></p>

<h5>3.1-6 IsomorphismSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>These functions compute an isomorphism from <var class="Arg">g</var> to a sphere group; the first form returns the isomorphism, while the second one returns its image.</p>

<p>DeclareAttribute("EulerCharacteristic", IsGroup);</p>

<p><a id="X8307F8DB85F145AE" name="X8307F8DB85F145AE"></a></p>

<h5>3.1-7 EulerCharacteristic</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EulerCharacteristic</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The Euler characteristic of <var class="Arg">g</var>.</p>

<p>The Euler characteristic of a free group of rank <span class="SimpleMath">n</span> is <span class="SimpleMath">1-n</span>; and it multiplies by the index on subgroups. A sphere group is finite if and only if its Euler characteristic is positive, and is virtually abelian if and only if its Euler characteristic is <span class="SimpleMath">0</span>.</p>

<p>DeclareAttribute("RankOfSphereGroup", IsSphereGroup);</p>

<p><a id="X81B9BA1586981067" name="X81B9BA1586981067"></a></p>

<h5>3.1-8 RankOfSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RankOfSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The number of generators of <var class="Arg">g</var>.</p>

<p>DeclareAttribute("OrderingOfSphereGroup", IsSphereGroup);</p>

<p><a id="X79A08D5C8532F976" name="X79A08D5C8532F976"></a></p>

<h5>3.1-9 OrderingOfSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; OrderingOfSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The list of the orders of the generators.</p>

<p>This attribute has the property that <code class="code">Product(GeneratorsOfGroup(g){OrderingOfSphereGroup(g)})</code> is the identity.</p>

<p>DeclareAttribute("ExponentsOfSphereGroup", IsSphereGroup);</p>

<p><a id="X7D973ED3816A1CBD" name="X7D973ED3816A1CBD"></a></p>

<h5>3.1-10 ExponentsOfSphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExponentsOfSphereGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The list of exponents of the generators.</p>

<p>This attribute has the property that <code class="code">GeneratorsOfGroup(g)[i]^ExponentsOfSphereGroup(g)[i]</code> is the identity for all <code class="code">i</code>. If an element has infinite order, the value stored is <code class="code">0</code>.</p>

<p>DeclareAttribute("IsomorphismFreeGroup", IsSphereGroup);</p>

<p><a id="X7ECF53F97DC06E4C" name="X7ECF53F97DC06E4C"></a></p>

<h5>3.1-11 IsomorphismFreeGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsomorphismFreeGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: An isomorphism to a free group, if it exists.</p>

<p>If <var class="Arg">g</var> was created as a sphere group with all exponents infinity, then <var class="Arg">g</var> is isomorphic to a free group on all the generators but one; this attribute stores such an isomorphism.</p>

<p>DeclareGlobalFunction("SphereGroup");</p>

<p><a id="X7DBBD32080770BD7" name="X7DBBD32080770BD7"></a></p>

<h5>3.1-12 SphereGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SphereGroup</code>( <var class="Arg">ordering</var>[, <var class="Arg">exponent</var>] )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A new sphere group.</p>

<p><var class="Arg">ordering</var> is either a list of integers, describing the order of the generators that is to be trivial; or an integer <code class="code">m</code>, in which case the ordering is <code class="code">[m,m-1,..,1]</code>.</p>

<p>The optional second argument <var class="Arg">exponent</var> is a list of integers describing the exponents of the generators. The value <code class="code">0</code> specifies a generator of infinite order.</p>

<p>DeclareProperty("IsSphereConjugacyClass", IsAssociativeElementCollection and IsMultiplicativeElementWithInverseCollection); DeclareProperty("IsSphereConjugacyClassCollection", IsAssociativeElementCollColl and IsMultiplicativeElementWithInverseCollColl); DeclareSynonym("IsMulticurve", IsSphereConjugacyClassCollection); DeclareOperation("InverseMutable", [IsSphereConjugacyClass]); DeclareOperation("InverseSameMutability", [IsSphereConjugacyClass]); DeclareAttribute("InverseImmutable", IsSphereConjugacyClass); DeclareOperation("POW", [IsSphereConjugacyClass,IsInt]);</p>

<p><a id="X8120094A7BFA9C48" name="X8120094A7BFA9C48"></a></p>

<h5>3.1-13 IsSphereConjugacyClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereConjugacyClass</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>Elements of a sphere group represent based loops on a punctured sphere. Loops (without specified basepoint) are represented by conjugacy classes. A <em>multicurve</em> is a collection of non-intersecting loops.</p>

<p>Conjugacy classes may be raised to integer powers; the <span class="SimpleMath">n</span>th power of a conjugacy class is the conjugacy class of the <span class="SimpleMath">n</span>th power of an element.</p>

<p>DeclareProperty("IsPeripheral", IsElementOfSphereGroup); DeclareProperty("IsPeripheral", IsSphereConjugacyClass);</p>

<p><a id="X8123456781234567" name="X8123456781234567"></a></p>

<h5>3.1-14 </h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; </code>( <var class="Arg">c</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: Whether the conjugacy class <var class="Arg">c</var> is peripheral.</p>

<p>A conjugacy class is <em>peripheral</em> if it contains a generator of the sphere group.</p>

<p>DeclareAttribute("PeripheralClasses", IsSphereGroup);</p>

<p><a id="X867DE11A7E9E02E7" name="X867DE11A7E9E02E7"></a></p>

<h5>3.1-15 PeripheralClasses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PeripheralClasses</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The peripheral conjugacy classes of <var class="Arg">g</var>.</p>

<p>DeclareOperation("IntersectionNumber", [IsSphereConjugacyClass,IsSphereConjugacyClass]); DeclareOperation("SelfIntersectionNumber", [IsSphereConjugacyClass]);</p>

<p><a id="X822BA8867B084B6C" name="X822BA8867B084B6C"></a></p>

<h5>3.1-16 IntersectionNumber</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IntersectionNumber</code>( <var class="Arg">c</var>, <var class="Arg">d</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The intersection number of the conjugacy classes <var class="Arg">c</var> and <var class="Arg">d</var>.</p>

<p>The <em>geometric intersection number</em> of two loops is the minimal number of intersections they may have. The <em>self-intersection number</em> of a loop is the intersection number of the loop with a small translate.</p>

<p>DeclareProperty("IsAutomorphismGroupOfSphereGroup", IsAutomorphismGroup); InstallTrueMethod(IsAutomorphismGroup, IsAutomorphismGroupOfSphereGroup); DeclareAttribute("EpimorphismToOut", IsAutomorphismGroupOfSphereGroup);</p>

<p><a id="X87677B0787B4461A" name="X87677B0787B4461A"></a></p>

<h5>3.1-17 AutomorphismGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismGroup</code>( <var class="Arg">g</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EpimorphismToOut</code>( <var class="Arg">a</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>This function computes the <em>pure</em> automorphism group of the sphere group <var class="Arg">g</var>, namely the group of automorphisms that preserves all the peripheral conjugacy classes (conjugacy classes of generators).</p>

<p>The attribute <code class="code">EpimorphismToOut</code> stores an epimorphism from the automorphism group to the group of outer automorphisms.</p>

<p>DeclareOperation("AmalgamatedFreeProduct", [IsSphereGroup,IsSphereGroup,IsElementOfSphereGroup,IsElementOfSphereGroup]); DeclareAttribute("EmbeddingsOfAmalgamatedFreeProduct", IsSphereGroup);</p>

<p><a id="X7A205FFD86D128B9" name="X7A205FFD86D128B9"></a></p>

<h5>3.1-18 AmalgamateFreeProduct</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AmalgamateFreeProduct</code>( <var class="Arg">g</var>, <var class="Arg">h</var>, <var class="Arg">x</var>, <var class="Arg">y</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This function computes the amalgamated free product of two sphere groups <var class="Arg">g</var> and <var class="Arg">h</var>, along the cyclic subgroups <span class="SimpleMath">⟨ x⟩</span> of <var class="Arg">g</var> and <span class="SimpleMath">⟨ y⟩</span> of <var class="Arg">h</var>.</p>

<p>The attribute <code class="code">EmbeddingsOfAmalgamatedFreeProduct</code> is a list of length two, storing the embeddings of <var class="Arg">g</var> and <var class="Arg">h</var> respectively into the amalgam.</p>

<p>DeclareGlobalFunction("NormalizedP1Map"); DeclareProperty("IsBicritical", IsObject);</p>

<p><a id="X8283D95B7FE74991" name="X8283D95B7FE74991"></a></p>

<h5>3.1-19 NormalizedP1Map</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalizedP1Map</code>( <var class="Arg">f</var>, <var class="Arg">M</var>, <var class="Arg">param</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: [A canonical conjugate of <var class="Arg">f</var>,the conjugator].</p>

<p>The last argument <var class="Arg">param</var> is either <code class="code">IsPolynomial</code>, <code class="code">IsBicritical</code> or a positive integer.</p>

<p>In the first case, the map <var class="Arg">f</var> is assumed conjugate to a polynomial. It is conjugated by a Möbius transformation that makes it a <em>centered</em> polynomial, namely a polynomial of the form <span class="SimpleMath">z^d+a_d-2z^d-2+dots+a_0</span>.</p>

<p>In the second case, the map <var class="Arg">f</var> is assumed to have only two critical values; it is normalized as <span class="SimpleMath">(az^d+b)/(cz^d+e)</span>.</p>

<p>In the third case, the map <var class="Arg">f</var> is assumed to have degree <span class="SimpleMath">2</span>; it is normalized in the form <span class="SimpleMath">1+a/z+b/z^2</span>, such that <span class="SimpleMath">0</span> is on a cycle of length <var class="Arg">param</var>.</p>

<p>DeclareOperation("ThurstonAlgorithm", [IsSphereMachine]);</p>

<p><a id="X7E423D047DB95301" name="X7E423D047DB95301"></a></p>

<h5>3.1-20 ThurstonAlgorithm</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ThurstonAlgorithm</code>( <var class="Arg">m</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: rec(map := f, machine := M, markedsphere := s).</p>

<p>This command runs Thurston's algorithm on the sphere machine <var class="Arg">m</var>. It either returns a record with the P1 map <code class="code">f</code> to which the algorithm converged, as well as the marked sphere with <code class="code">f</code>'s post-critical set and a simplified machine equivalent to <var class="Arg">m</var>; or a record returned by <code class="func">ThurstonObstruction</code> (<a href="chap3.html#X787168378397C957"><span class="RefLink">3.1-23</span></a>).</p>

<p>DeclareOperation("P1MapBySphereMachine", [IsSphereMachine]);</p>

<p><a id="X7A6170147F1376F2" name="X7A6170147F1376F2"></a></p>

<h5>3.1-21 P1MapBySphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; P1MapBySphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: Either a map or an obstruction.</p>

<p>This command returs either the map computed by <code class="func">ThurstonAlgorithm</code> (<a href="chap3.html#X7E423D047DB95301"><span class="RefLink">3.1-20</span></a>) or a Thurston obstruction.</p>

<p>It runs a modification of Hubbard and Schleicher's "spider algorithm" <a href="chapBib.html#biBMR1315537">[HS94]</a> on the sphere machine <var class="Arg">m</var>.</p>

<p>The command accepts the following options, to return a map in a given normalization:</p>


<dl>
<dt><strong class="Mark"><code class="code">P1MapBySphereMachine(m:param:=IsPolynomial)</code></strong></dt>
<dd><p>returns <span class="SimpleMath">f=z^d+A_d-2z^d-2+⋯+A_0</span>;</p>

</dd>
<dt><strong class="Mark"><code class="code">P1MapBySphereMachine(m:param:=IsBicritical)</code></strong></dt>
<dd><p>returns <span class="SimpleMath">f=((pz+q)/(rz+s)^d</span>, with <span class="SimpleMath">1</span>postcritical;</p>

</dd>
<dt><strong class="Mark"><code class="code">P1MapBySphereMachine(m:param:=n)</code></strong></dt>
<dd><p>returns <span class="SimpleMath">f=1+a/z+b/z^2</span> or <span class="SimpleMath">f=a/(z^2+2z)</span> if <code class="code">n=2</code>.</p>

</dd>
</dl>

<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := PolynomialSphereMachine(2,[1/3],[]);</span>
&lt;FR machine with alphabet [ 1, 2 ] on Group( [ f1, f2, f3 ] )/[ f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">P1MapBySphereMachine(m);</span>
0.866025*z^2+(-1)*z+(-0.288675)
</pre></div>

<p>DeclareOperation("ThurstonMatrix", [IsSphereMachine,IsMulticurve]);</p>

<p><a id="X807FAD4982B21B2A" name="X807FAD4982B21B2A"></a></p>

<h5>3.1-22 ThurstonMatrix</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ThurstonMatrix</code>( <var class="Arg">m</var>, <var class="Arg">multicurve</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The transition matrix of the multicurve.</p>

<p>This command computes the iterated preimages of the multicurve <var class="Arg">multicurve</var> till it obtains a backwards-invariant multicurve or some preimages intersect. In the latter case, <code class="keyw">fail</code> returned, while in the former case the Thurston matrix of the multicurve is returned.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[],[1/6]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1,F.2^(F.3*F.2),F.3^F.2,F.4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r*twist^-1);</span>
rec( machine := &lt;FR machine with alphabet [ 1, 2 ] on F/[ f4*f1*f2*f3 ]&gt;,
     twist := [ f1, f2, f3, f4 ] -&gt; [ f1, f3^-1*f2*f3, f3^-1*f2^-1*f3*f2*f3, f4 ],
     obstruction := "Dehn twist" )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ThurstonMatrix(last.machine,[ConjugacyClass(F.2*F.3)]);</span>
[ [ 1 ] ]
</pre></div>

<p>DeclareOperation("ThurstonObstruction", [IsSphereMachine,IsMarkedSphere]);</p>

<p><a id="X787168378397C957" name="X787168378397C957"></a></p>

<h5>3.1-23 ThurstonObstruction</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ThurstonObstruction</code>( <var class="Arg">m</var>, <var class="Arg">sphere</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: rec(multicurve := mc, matrix := m) or <code class="keyw">fail</code>.</p>

<p>This command tries to find a Thurston obstruction (multicurve such that its Thurston matrix has spectral radius at least <span class="SimpleMath">1</span>); it either returns <code class="keyw">fail</code> if the search was inconclusive, or a record describing the obstruction.</p>

<p>The obstruction is searched for by considering small subtrees of the minimal spanning tree of <var class="Arg">sphere</var>, computing loops surrounding these subtrees, and saturating them into a multicurve by taking their iterated preimages, see <code class="func">ThurstonMatrix</code> (<a href="chap3.html#X807FAD4982B21B2A"><span class="RefLink">3.1-22</span></a>).</p>

<p>DeclareProperty("IsKneadingMachine",IsFRMachine); DeclareProperty("IsPlanarKneadingMachine",IsFRMachine); InstallTrueMethod(IsBoundedFRMachine,IsKneadingMachine); InstallTrueMethod(IsLevelTransitive,IsKneadingMachine);</p>

<p><a id="X84C2881D87C1FB74" name="X84C2881D87C1FB74"></a></p>

<h5>3.1-24 IsKneadingMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsKneadingMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( property )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsPlanarKneadingMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( property )</td></tr></table></div>
<p>Returns: Whether <var class="Arg">m</var> is a (planar) kneading machine.</p>

<p>A <em>kneading machine</em> is a special kind of Mealy machine, used to describe postcritically finite complex polynomials. It is a machine such that its set of permutations is "treelike" (see <a href="chapBib.html#biBMR2162164">[Nek05, §6.7]</a>) and such that each non-trivial state occurs exactly once among the outputs.</p>

<p>Furthermore, this set of permutations is <em>treelike</em> if there exists an ordering of the states that their product in that order <span class="SimpleMath">t</span> is an adding machine; i.e. such that <span class="SimpleMath">t</span>'s activity is a full cycle, and the product of its states along that cycle is conjugate to <span class="SimpleMath">t</span>. This element <span class="SimpleMath">t</span> represents the Carathéodory loop around infinity.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := BinaryKneadingMachine("0");</span>
BinaryKneadingMachine("0*")
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(M);</span>
   |  1     2
---+-----+-----+
 a | c,2   b,1
 b | a,1   c,2
 c | c,1   c,2
---+-----+-----+
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarKneadingMachine(M);</span>
true
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">IsPlanarKneadingMachine(GrigorchukMachine);</span>
false
</pre></div>

<p>DeclareAttribute("AddingElement", IsSphereMachine);</p>

<p><a id="X82F34D5387FF4E57" name="X82F34D5387FF4E57"></a></p>

<h5>3.1-25 AddingElement</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddingElement</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The element generating the adding submachine.</p>

<p>This attribute stores the product of generators that is an adding machine. In essence, it records an ordering of the generators whose product corresponds to the Carathéodory loop around infinity.</p>

<p>The following example illustrates Wittner's shared mating of the airplane and the rabbit. In the machine <code class="code">m</code>, an airplane is represented by <code class="code">Group(a,b,c)</code> and a rabbit is represented by <code class="code">Group(x,y,z)</code>; in the machine <code class="code">newm</code>, it is the other way round. The effect of <code class="code">CleanedIMGMachine</code> was to remove unnecessary instances of the IMG relator from <code class="code">newm</code>'s recursion.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">f := FreeGroup("a","b","c","x","y","z");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AssignGeneratorVariables(f);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := AsSphereMachine(FRMachine(f,[[a^-1,b*a],[One(f),c],[a,One(f)],[z*y*x,</span>
       x^-1*y^-1],[One(f),x],[One(f),y]],[(1,2),(),(),(1,2),(),()]));;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(m);</span>
 G |      1             2   
---+---------+-------------+
 a |  a^-1,2         b*a,1  
 b |  &lt;id&gt;,1           c,2  
 c |     a,1        &lt;id&gt;,2  
 x | z*y*x,2   x^-1*y^-1,1  
 y |  &lt;id&gt;,1           x,2  
 z |  &lt;id&gt;,1           y,2  
---+---------+-------------+
Relator: z*y*x*c*b*a
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">iso := GroupHomomorphismByImages(f,f,[a,b^(y^-1),c^(x^-1*y^-1*a^-1),x^(b*a*z*a^-1),y,z^(a^-1)],[a,b,c,x,y,z]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">newm := CleanedSphereMachine(ChangeFRMachineBasis(m^iso,[a^-1*y^-1,y^-1*a^-1*c^-1]));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(newm);</span>
 G |          1         2   
---+-------------+---------+
 a | a^-1*c^-1,2   c*a*b,1  
 b |      &lt;id&gt;,1       c,2  
 c |         a,1    &lt;id&gt;,2  
 x |       z*x,2    x^-1,1  
 y |      &lt;id&gt;,1       x,2  
 z |         y,1    &lt;id&gt;,2  
---+-------------+---------+
Relator: c*a*b*y*z*x
</pre></div>

<p>DeclareSynonym("IsPolynomialSphereMachine",IsSphereMachine and HasAddingElement); DeclareAttribute("AsPolynomialSphereMachine",IsFRMachine); DeclareOperation("AsPolynomialSphereMachine",[IsFRMachine,IsWord]);</p>

<p><a id="X7BE171B879357604" name="X7BE171B879357604"></a></p>

<h5>3.1-26 AsPolynomialSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AsPolynomialSphereMachine</code>( <var class="Arg">m</var>[, <var class="Arg">adder</var>[, <var class="Arg">relator</var>]] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A polynomial sphere machine.</p>

<p>The first function creates a new polynomial sphere machine, starting from a group or Mealy machine. A <em>polynomial</em> machine is one that has a distinguished adding element, <code class="func">AddingElement</code> (<a href="chap3.html#X82F34D5387FF4E57"><span class="RefLink">3.1-25</span></a>).</p>

<p>If the argument is a Mealy machine, it must be planar (see <code class="func">IsPlanarKneadingMachine</code> (<a href="chap3.html#X84C2881D87C1FB74"><span class="RefLink">3.1-24</span></a>)). If the argument is a group machine, its permutations must be treelike, and its outputs must be such that, up to conjugation, each non-trivial state appears exactly once as the product along all cycles of all states.</p>

<p>If a second argument <var class="Arg">adder</var> is supplied, it is checked to represent an adding element, and is used as such.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">M := PolynomialMealyMachine(2,[1/7],[]);</span>
!!!
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Mi := AsPolynomialSphereMachine(M);</span>
!!!
</pre></div>

<p>DeclareOperation("PolynomialMealyMachine",[IsPosInt,IsList,IsList]); DeclareOperation("PolynomialMealyMachine",[IsPosInt,IsList]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsList,IsRecord]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsList]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList,IsRecord]); DeclareOperation("PolynomialSphereMachine",[IsPosInt,IsList]);</p>

<p><a id="X80E689F38412EE20" name="X80E689F38412EE20"></a></p>

<h5>3.1-27 PolynomialSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolynomialSphereMachine</code>( <var class="Arg">d</var>, <var class="Arg">per</var>[, <var class="Arg">pre</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PolynomialMealyMachine</code>( <var class="Arg">d</var>, <var class="Arg">per</var>[, <var class="Arg">pre</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere or Mealy machine.</p>

<p>This function creates a sphere or Mealy machine that describes a topological polynomial. The polynomial is described symbolically in the language of <em>external angles</em>. For more details, see <a href="chapBib.html#biBMR762431">[DH84]</a> and <a href="chapBib.html#biBMR812271">[DH85]</a> (in the quadratic case), <a href="chapBib.html#biBMR1149891">[BFH92]</a> (in the preperiodic case), and <a href="chapBib.html#biBmath.DS/9305207">[Poi]</a> (in the general case).</p>

<p><var class="Arg">d</var> is the degree of the polynomial. <var class="Arg">per</var> and <var class="Arg">pre</var> are lists of angles or preangles. In what follows, angles are rational numbers, considered modulo 1. Each entry in <var class="Arg">per</var> or <var class="Arg">pre</var> is either a rational (interpreted as an angle), or a list of angles <span class="SimpleMath">[a_1,...,a_i]</span> such that <span class="SimpleMath">da_1=...=da_i</span>. The angles in <var class="Arg">per</var> are angles landing at the root of a Fatou component, and the angles in <var class="Arg">pre</var> land on the Julia set.</p>

<p>Note that, for sphere machines, the last generator of the machine produced is an adding machine, representing a loop going counterclockwise around infinity (in the compactification of <span class="SimpleMath">C</span> by a disk, this loop goes <em>clockwise</em> around that disk).</p>

<p>In constructing a polynomial sphere machine, one may specify a boolean flag <var class="Arg">formal</var>, which defaults to <code class="keyw">true</code>. In a <em>formal</em> recursion, distinct angles give distinct generators; while in a non-formal recursion, distinct angles, which land at the same point in the Julia set, give a single generator. The simplest example where this occurs is angle <span class="SimpleMath">5/12</span> in the quadratic family, in which angles <span class="SimpleMath">1/3</span> and <span class="SimpleMath">2/3</span> land at the same point -- see the example below.</p>

<p>The attribute <code class="code">Correspondence(m)</code> records the angles landing on the generators: <code class="code">Correspondence(m)[i]</code> is a list <code class="code">[a,s]</code> where <span class="SimpleMath">a</span> is an angle landing on generator <code class="code">i</code> and <span class="SimpleMath">s</span> is <code class="keyw">"Julia"</code> or <code class="keyw">"Fatou"</code>.</p>

<p>If only one list of angles is supplied, then <strong class="pkg">IMG</strong> guesses that all angles with denominator coprime to <var class="Arg">n</var> are Fatou, and all the others are Julia.</p>

<p>The inverse operation, reconstructing the angles from the sphere machine, is <code class="func">SupportingRays</code> (<a href="chap3.html#X814E27317A6213D3"><span class="RefLink">3.1-28</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[0],[]); # the adding machine</span>
&lt;FR machine with alphabet [ 1 .. 2 ] on Group( [ f1, f2 ] )/[ f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |     1        2
----+--------+--------+
 f1 | &lt;id&gt;,2     f1,1
 f2 |   f2,2   &lt;id&gt;,1
----+--------+--------+
Relator: f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PolynomialSphereMachine(2,[1/3],[])); # the Basilica</span>
 G  |      1         2
----+---------+---------+
 f1 | f1^-1,2   f2*f1,1
 f2 |    f1,1    &lt;id&gt;,2
 f3 |    f3,2    &lt;id&gt;,1
----+---------+---------+
Relator: f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(PolynomialSphereMachine(2,[],[1/6])); # z^2+I</span>
 G  |            1         2
----+---------------+---------+
 f1 | f1^-1*f2^-1,2   f2*f1,1
 f2 |          f1,1      f3,2
 f3 |          f2,1    &lt;id&gt;,2
 f4 |          f4,2    &lt;id&gt;,1
----+---------------+---------+
Relator: f4*f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[],[5/12]);</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[],[5/12]);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f5 on Group( [ f1, f2, f3, f4, f5 ] )/[ f5*f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Correspondence(last);</span>
[ [ 1/3, "Julia" ], [ 5/12, "Julia" ], [ 2/3, "Julia" ], [ 5/6, "Julia" ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">PolynomialSphereMachine(2,[],[5/12],false);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Correspondence(last);</span>
[ [ [ 1/3, 2/3 ], "Julia" ], [ [ 5/12 ], "Julia" ], [ [ 5/6 ], "Julia" ] ]
</pre></div>

<p>The following construct the examples in Poirier's paper:</p>


<div class="example"><pre>
PoirierExamples := function(arg)
    if arg=[1] then
        return PolynomialSphereMachine(2,[1/7],[]);
    elif arg=[2] then
        return PolynomialSphereMachine(2,[],[1/2]);
    elif arg=[3,1] then
        return PolynomialSphereMachine(2,[],[5/12]);
    elif arg=[3,2] then
        return PolynomialSphereMachine(2,[],[7/12]);
    elif arg=[4,1] then
        return PolynomialSphereMachine(3,[[3/4,1/12],[1/4,7/12]],[]);
    elif arg=[4,2] then
        return PolynomialSphereMachine(3,[[7/8,5/24],[5/8,7/24]],[]);
    elif arg=[4,3] then
        return PolynomialSphereMachine(3,[[1/8,19/24],[3/8,17/24]],[]);
    elif arg=[5] then
        return PolynomialSphereMachine(3,[[3/4,1/12],[3/8,17/24]],[]);
    elif arg=[6,1] then
        return PolynomialSphereMachine(4,[],[[1/4,3/4],[1/16,13/16],[5/16,9/16]]);
    elif arg=[6,2] then
        return PolynomialSphereMachine(4,[],[[1/4,3/4],[3/16,15/16],[7/16,11/16]]);
    elif arg=[7] then
        return PolynomialSphereMachine(5,[[0,4/5],[1/5,2/5,3/5]],[[1/5,4/5]]);
    elif arg=[9,1] then
        return PolynomialSphereMachine(3,[[0,1/3],[5/9,8/9]],[]);
    elif arg=[9,2] then
        return PolynomialSphereMachine(3,[[0,1/3]],[[5/9,8/9]]);
    else
        Error("Unknown Poirier example ",arg);
    fi;
end;
</pre></div>

<p>DeclareAttribute("SupportingRays",IsFRMachine);</p>

<p><a id="X814E27317A6213D3" name="X814E27317A6213D3"></a></p>

<h5>3.1-28 SupportingRays</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SupportingRays</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A <code class="code">[degree,fatou,julia]</code> description of <var class="Arg">m</var>.</p>

<p>This operation is the inverse of <code class="func">PolynomialSphereMachine</code> (<a href="chap3.html#X80E689F38412EE20"><span class="RefLink">3.1-27</span></a>): it computes a choice of angles, describing landing rays on Fatou/Julia critical points.</p>

<p>If there does not exist a complex realization, namely if the machine is obstructed, then this command returns an obstruction, as a record. The field <code class="keyw">minimal</code> is set to false, and a proper sub-machine is set as the field <code class="keyw">submachine</code>. The field <code class="keyw">homomorphism</code> gives an embedding of the stateset of <code class="keyw">submachine</code> into the original machine, and <code class="keyw">relation</code> is the equivalence relation on the set of generators of <var class="Arg">m</var> that describes the pinching.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[1/7],[]);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r);</span>
[ 2, [ [ 1/7, 9/14 ] ], [  ] ] # actually returns the angle 2/7
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># now CallFuncList(PolynomialSphereMachine,last) would return the machine r</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1^(F.2*F.1),F.2^F.1,F.3,F.4])^-1;</span>
[ f1, f2, f3, f4 ] -&gt; [ f1*f2*f1^-1, f2*f1*f2*f1^-1*f2^-1, f3, f4 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([-5..5],i-&gt;2*SupportingRays(r*twist^i)[2][1][1]);</span>
[ 4/7, 5/7, 4/7, 4/7, 5/7, 2/7, 4/7, 4/7, 2/7, 4/7, 4/7 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[],[1/6]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1,F.2^(F.3*F.2),F.3^F.2,F.4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r);</span>
[ 2, [  ], [ [ 1/12, 7/12 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r*twist);</span>
[ 2, [  ], [ [ 5/12, 11/12 ] ] ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SupportingRays(r*twist^2);</span>
rec(
  transformation := [ [ f1, f2^-1*f3^-1*f2^-1*f3^-1*f2*f3*f2*f3*f2, f2^-1*f3^-1*f2^-1*f3*f2*f3*f2,
          f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1^-1*f2^-1*f1^-1*f2^-1*f1*f2*f1*f2*f1, f1^-1*f2^-1*f1^-1*f2*f1*f2*f1, f3, f4 ] -&gt;
        [ f1, f2, f3, f4 ],
      [ f1^-1*f2^-1*f3^-1*f2*f1*f2^-1*f3*f2*f1, f2, f2*f1^-1*f2^-1*f3*f2*f1*f2^-1, f4 ] -&gt;
        [ f1, f2, f3, f4 ], [ f1, f3*f2*f3^-1, f3, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f2, f2*f3*f2^-1, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f3*f2*f3^-1, f3, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f2, f2*f3*f2^-1, f4 ] -&gt; [ f1, f2, f3, f4 ],
      [ f1, f3*f2*f3^-1, f3, f4 ] -&gt; [ f1, f2, f3, f4 ] ], machine := &lt;FR machine with alphabet
    [ 1, 2 ] and adder f4 on Group( [ f1, f2, f3, f4 ] )/[ f4*f3*f2*f1 ]&gt;, minimal := false,
  submachine := &lt;FR machine with alphabet [ 1, 2 ] and adder f3 on Group( [ f1, f2, f3 ] )&gt;,
  homomorphism := [ f1, f2, f3 ] -&gt; [ f1, f2*f3, f4 ],
  relation := &lt;equivalence relation on &lt;object&gt; &gt;, niter := 8 )
</pre></div>

<p>DeclareAttribute("NormalizedPolynomialSphereMachine",IsSphereMachine);</p>

<p><a id="X7EE9C721802D481B" name="X7EE9C721802D481B"></a></p>

<h5>3.1-29 NormalizedPolynomialSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NormalizedPolynomialSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A polynomial sphere machine.</p>

<p>This function returns a new sphere machine, in which the adding element has been put into a standard form <span class="SimpleMath">t=[t,1,dots,1]s</span>, where <span class="SimpleMath">s</span> is the long cycle <span class="SimpleMath">i↦ i-1</span>.</p>

<p>DeclareAttribute("SimplifiedSphereMachine",IsSphereMachine);</p>

<p><a id="X81B7D47D81212C4F" name="X81B7D47D81212C4F"></a></p>

<h5>3.1-30 SimplifiedSphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SimplifiedSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A simpler sphere machine.</p>

<p>This function returns a new sphere machine, with hopefully simpler transitions. The simplified machine is obtained by applying automorphisms to the stateset. The sequence of automorphisms (in increasing order) is stored as a correspondence; namely, if <code class="code">n=SimplifiedSphereMachine(m)</code>, then <code class="code">m^Product(Correspondence(n))=n</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">r := PolynomialSphereMachine(2,[1/7],[]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">F := StateSet(r);; SetName(F,"F");</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">twist := GroupHomomorphismByImages(F,F,GeneratorsOfGroup(F),[F.1^(F.2*F.1),F.2^F.1,F.3,F.4]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := r*twist;; Display(m);</span>
 G  |                     1            2
----+------------------------+------------+
 f1 |          f1^-1*f2^-1,2   f3*f2*f1,1
 f2 | f1^-1*f2^-1*f1*f2*f1,1       &lt;id&gt;,2
 f3 |          f1^-1*f2*f1,1       &lt;id&gt;,2
 f4 |                   f4,2       &lt;id&gt;,1
----+------------------------+------------+
Adding element: f4
Relator: f4*f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n := SimplifiedSphereMachine(m);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder f4 on F&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(n);</span>
 G  |            1            2
----+---------------+------------+
 f1 | f2^-1*f1^-1,2   f1*f2*f3,1
 f2 |        &lt;id&gt;,1         f1,2
 f3 |        &lt;id&gt;,1         f2,2
 f4 |          f4,2       &lt;id&gt;,1
----+---------------+------------+
Adding element: f4
Relator: f4*f1*f2*f3
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">n = m^Product(Correspondence(n));</span>
true
</pre></div>

<p>DeclareOperation("Mating",[IsPolynomialSphereMachine,IsPolynomialSphereMachine]); DeclareOperation("Mating",[IsPolynomialSphereMachine,IsPolynomialSphereMachine,IsBool]);</p>

<p><a id="X7AB029AE8590964E" name="X7AB029AE8590964E"></a></p>

<h5>3.1-31 Mating</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Mating</code>( <var class="Arg">m1</var>, <var class="Arg">m2</var>[, <var class="Arg">formal</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere machine.</p>

<p>This function "mates" two polynomial sphere machines.</p>

<p>The mating is defined as follows: one removes a disc around the adding machine in <var class="Arg">m1</var> and <var class="Arg">m2</var>; one applies complex conjugation to <var class="Arg">m2</var>; and one glues the hollowed spheres along their boundary circle.</p>

<p>The optional argument <var class="Arg">formal</var>, which defaults to <code class="keyw">true</code>, specifies whether a <em>formal</em> mating should be done; in a non-formal mating, generators of <var class="Arg">m1</var> and <var class="Arg">m2</var> which have identical angle should be treated as a single generator. A non-formal mating is of course possible only if the machines are realizable -- see <code class="func">SupportingRays</code> (<a href="chap3.html#X814E27317A6213D3"><span class="RefLink">3.1-28</span></a>).</p>

<p>The attribute <code class="code">Correspondence</code> is a pair of homomorphisms, from the statesets of <var class="Arg">m1,m2</var> respectively to the stateset of the mating.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># the Tan-Shishikura examples</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Indeterminate(MPC_PSEUDOFIELD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := RootsFloat((z-1)*(3*z^2-2*z^3)+1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">c := RootsFloat((z^3+z)^3+z);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">am := List(a,a-&gt;SphereMachine((a-1)*(3*z^2-2*z^3)+1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cm := List(c,c-&gt;SphereMachine(z^3+c));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := ListX(am,cm,Mating);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># m[2] is realizable</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RationalFunction(m[2]);</span>
((1.66408+I*0.668485)*z^3+(-2.59772+I*0.627498)*z^2+(-1.80694-I*0.833718)*z
  +(1.14397-I*1.38991))/((-1.52357-I*1.27895)*z^3+(2.95502+I*0.234926)*z^2
  +(1.61715+I*1.50244)*z+1)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># m[6] is obstructed</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">RationalFunction(m[6]);</span>
rec( matrix := [ [ 1/2, 1 ], [ 1/2, 0 ] ], machine := &lt;FR machine with alphabet
    [ 1, 2, 3 ] on Group( [ f1, f2, f3, g1, g2, g3 ] )/[ f2*f3*f1*g1*g3*g2 ]&gt;,
  obstruction := [ f1^-1*f3^-1*f2^-1*f1*f2*f3*f1*g2^-1*g3^-1*f1^-1*f3^-1*f2^-1,
      f2*f3*f1*f2*f3*f1*g2*f1^-1*f3^-1*f2^-1*f1^-1*f3^-1 ],
  spider := &lt;spider on &lt;triangulation with 8 vertices, 36 edges and
    12 faces&gt; marked by GroupHomomorphismByImages( Group( [ f1, f2, f3, g1, g2, g3
     ] ), Group( [ f1, f2, f3, f4, f5 ] ), [ f1, f2, f3, g1, g2, g3 ],
    [ f1*f4*f2^-1*f1*f4^-1*f1^-1, f1*f4*f2^-1*f1*f4*f5^-1*f1^-1*f2*f4^-1*f1^-1,
      f1*f4*f2^-1*f1*f5*f1^-1*f2*f4^-1*f1^-1, f2*f4^-1*f1^-1*f2*f1*f4*f2^-1,
      f2*f4^-1*f3*f2^-1, f2*f4^-1*f1^-1*f3^-1*f4*f2^-1 ] )&gt; )
</pre></div>

<p>DeclareOperation("AutomorphismVirtualEndomorphism",[IsGroupHomomorphism]); DeclareOperation("AutomorphismSphereMachine",[IsSphereMachine]);</p>

<p><a id="X8410869F8358A1AF" name="X8410869F8358A1AF"></a></p>

<h5>3.1-32 AutomorphismVirtualEndomorphism</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismVirtualEndomorphism</code>( <var class="Arg">v</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AutomorphismSphereMachine</code>( <var class="Arg">m</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: A description of the pullback map on Teichmüller space.</p>

<p>Let <var class="Arg">m</var> be a sphere machine, thought of as a biset for the fundamental group <span class="SimpleMath">G</span> of a punctured sphere. Let <span class="SimpleMath">M</span> denote the automorphism of the surface, seen as a group of outer automorphisms of <span class="SimpleMath">G</span> that fixes the conjugacy classes of punctures.</p>

<p>Choose an alphabet letter <var class="Arg">a</var>, and consider the virtual endomorphism <span class="SimpleMath">v:G_a-&gt; G</span>. Let <span class="SimpleMath">H</span> denote the subgroup of <span class="SimpleMath">M</span> that fixes all conjugacy classes of <span class="SimpleMath">G_a</span>. then there is an induced virtual endomorphism <span class="SimpleMath">α:H-&gt; M</span>, defined by <span class="SimpleMath">t^α=v^-1tv</span>. This is the homomorphism computed by the first command. Its source and range are in fact groups of automorphisms of range of <var class="Arg">v</var>.</p>

<p>The second command constructs an FR machine associated with <var class="Arg">\alpha</var>. Its stateset is a free group generated by elementary Dehn twists of the generators of <var class="Arg">G</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Indeterminate(COMPLEX_FIELD);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># a Sierpinski carpet map without multicurves</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := SphereMachine((z^2-z^-2)/2/COMPLEX_I);</span>
&lt;FR machine with alphabet [ 1, 2, 3, 4 ] on Group( [ f1, f2, f3, f4 ] )/[ f3*f2*f1*f4 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AutomorphismSphereMachine(i);</span>
&lt;FR machine with alphabet [ 1, 2 ] on Group( [ x1, x2, x3, x4, x5, x6 ] )&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |     1        2
----+--------+--------+
 x1 | &lt;id&gt;,2   &lt;id&gt;,1  
 x2 | &lt;id&gt;,1   &lt;id&gt;,2  
 x3 | &lt;id&gt;,2   &lt;id&gt;,1  
 x4 | &lt;id&gt;,2   &lt;id&gt;,1  
 x5 | &lt;id&gt;,1   &lt;id&gt;,2  
 x6 | &lt;id&gt;,2   &lt;id&gt;,1  
----+--------+--------+
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># the original rabbit problem</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := PolynomialSphereMachine(2,[1/7],[]);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">v := VirtualEndomorphism(m,1);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := AutomorphismVirtualEndomorphism(v);</span>
MappingByFunction( &lt;group with 20 generators&gt;, &lt;group with 6 generators&gt;, function( a ) ... end )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Source(a).1;</span>
[ f1, f2, f3, f4 ] -&gt; [ f3*f2*f1*f2^-1*f3^-1, f2, f3, f3*f2*f1^-1*f2^-1*f3^-1*f2^-1*f3^-1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Image(a,last);</span>
[ f1, f2, f3, f4 ] -&gt; [ f1, f2, f2*f1*f3*f1^-1*f2^-1, f3^-1*f1^-1*f2^-1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># so last2*m is equivalent to m*last</span>
</pre></div>

<p>DeclareGlobalFunction("DBRationalIMGGroup");</p>

<p><a id="X82F0B23486F2E3AC" name="X82F0B23486F2E3AC"></a></p>

<h5>3.1-33 DBRationalIMGGroup</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DBRationalIMGGroup</code>( <var class="Arg">sequence/map</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An IMG group from Dau's database.</p>

<p>This function returns the iterated monodromy group from a database of groups associated to quadratic rational maps. This database has been compiled by Dau Truong Tan <a href="chapBib.html#biBtan:database">[Tan02]</a>.</p>

<p>When called with no arguments, this command returns the database contents in raw form.</p>

<p>The argments can be a sequence; the first integer is the size of the postcritical set, the second argument is an index for the postcritical graph, and sometimes a third argument distinguishes between maps with same post-critical graph.</p>

<p>If the argument is a rational map, the command returns the IMG group of that map, assuming its canonical quadratic rational form form exists in the database.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DBRationalIMGGroup(z^2-1);</span>
IMG((z-1)^2)
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DBRationalIMGGroup(z^2+1); # not post-critically finite</span>
fail
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DBRationalIMGGroup(4,1,1);</span>
IMG((z/h+1)^2|2h^3+2h^2+2h+1=0,h~-0.64)
</pre></div>

<p>DeclareGlobalFunction("PostCriticalMachine");</p>

<p><a id="X8365719F7E03B7C3" name="X8365719F7E03B7C3"></a></p>

<h5>3.1-34 PostCriticalMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; PostCriticalMachine</code>( <var class="Arg">f</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The Mealy machine of <var class="Arg">f</var>'s post-critical orbit.</p>

<p>This function constructs a Mealy machine <code class="code">P</code> on the alphabet <code class="code">[1]</code>, which describes the post-critical set of <var class="Arg">f</var>. It is in fact an oriented graph with constant out-degree 1. It is most conveniently passed to <code class="func">Draw</code> (<a href="/Users/laurent/.gap/pkg/fr/doc/chap5.html#X7DF9F3AD86602DFC"><span class="RefLink">FR: Draw</span></a>).</p>

<p>The attribute <code class="code">Correspondence(P)</code> is the list of values associated with the stateset of <code class="code">P</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := Indeterminate(Rationals,"z");;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := PostCriticalMachine(z^2);</span>
&lt;Mealy machine on alphabet [ 1 ] with 2 states&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(m);</span>
   |  1
---+-----+
 a | a,1
 b | b,1
---+-----+
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Correspondence(m);</span>
[ 0, infinity ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">m := PostCriticalMachine(z^2-1);; Display(m); Correspondence(m);</span>
   |  1
---+-----+
 a | c,1
 b | b,1
 c | a,1
---+-----+
[ -1, infinity, 0 ]
</pre></div>

<p><a id="X7C73C74D87428A33" name="X7C73C74D87428A33"></a></p>

<h4>3.2 <span class="Heading">Spiders</span></h4>

<p><strong class="pkg">IMG</strong> contains an implementation of the Thurston-Hubbard-Schleicher "spider algorithm" <a href="chapBib.html#biBMR1315537">[HS94]</a> that constructs a rational map from an IMG recursion. This implementation does not give rigourous results, but relies of floating-point approximation. In particular, various floating-point parameters control the proper functioning of the algorithm. They are stored in a record, <code class="code">EPS@fr</code>. Their meaning and default values are:</p>


<dl>
<dt><strong class="Mark"><code class="code">EPS@fr.mesh := 10^-1</code></strong></dt>
<dd><p>If points on the unit sphere are that close, the triangulation mesh should be refined.</p>

</dd>
<dt><strong class="Mark"><code class="code">EPS@fr.prec := 10^-6</code></strong></dt>
<dd><p>If points on the unit sphere are that close, they are considered equal.</p>

</dd>
<dt><strong class="Mark"><code class="code">EPS@fr.obst := 10^-1</code></strong></dt>
<dd><p>If points on the unit sphere are that close, they are suspected to form a Thurston obstruction.</p>

</dd>
<dt><strong class="Mark"><code class="code">EPS@fr.juliaiter := 10^3</code></strong></dt>
<dd><p>In computing images of the Julia set, never recur deeper than that.</p>

</dd>
<dt><strong class="Mark"><code class="code">EPS@fr.fast := 10^-1</code></strong></dt>
<dd><p>If the spider moved less than that amount in the last iteration, try speeding up by only wiggling the spider's legs, without recomputing it.</p>

</dd>
<dt><strong class="Mark"><code class="code">EPS@fr.ratprec := 10^-10</code></strong></dt>
<dd><p>The desired precision on the coefficients of the rational function.</p>

</dd>
</dl>
<p>..... (a) there is a concept of "marked sphere". It is made of an N-generated group, a collection of N elements of P^1(C) called "feet", a triangulation of the sphere that includes these elements among its vertices, and a marking of the edges by elements of the group in such a manner that a loop around point i is conjugate to generator i. To keep track of "loops around things", the triangulation also remembers its dual graph. (b) given a marked sphere and a rational map (given by coefficients), a procedure computes the "lifted marked sphere" and a wreath recursion between their respective groups, i.e. a homomorphism G_{below} \to G_{above} wr sym(d). The procedure will probably fail unless the critical values are close to the feet. There, the algorithm is already subtle: edges of the dual graph are represented by arcs of great circles. One first computes the full preimage of the feet, and a triangulation spanning them on a sphere "above" the original marked sphere. Then, for each edge of the "down" dual graph, its preimage on the "up" sphere is an algebraic curve. One computes its intersections with all edges of the "up" dual graph, by finding zeroes of real polynomials, to determine from which triangle to which one the lifted edges go. Because of rounding errors, one has to be careful as to when a real polynomial is supposed to have a zero, or when a point is supposed to be in a triangle. E.g., if T is a triangle and its sides are given by arcs of great circles, represented as gamma_i([0,1]) for Moebius maps gamma_i, i=1,2,3, then the test "Im(gamma_i(z))&gt;0 forall i" determines whether z is in the triangle. This test is really coded as "Im(gamma_i(z)) / (1+|gamma_i(z)|^2) &gt; -@IMG.p1eps" to take care of rounding errors. (c) given a marked sphere and a permutation representation of its group, a procedure computes a rational map with that monodromy. If the representation has degree 2, or is bicritical, or a few other cases easily coded by hand, then the rational map is computed algebraically. Otherwise, the "hard" part of the algorithm comes into play. A fresh marked sphere is constructed with only the feet with non-trivial permutation. The triangulation is then combinatorially lifted, using the permutation representation. In particular, the feet are now labeled by cycles of the permutations. It is a purely combinatorial triangulation, at this point; but one remembers that its edges have a length inherited from the sphere metric. The triangulation is then refined by repeatedly adding circumcentres of triangles, till every edge (say from v to w) has length \le @IMG.hurwitzmesh ^ Maximum(cycle length at v, cycle length at w). Now an external C program, "layout", is called. It seeks a discrete conformal map, given by a function u: {feet} \to R, such that if edge e (from v to w) has its length scaled by u(v)*u(w) then the sum-of-angles=2pi condition holds at each vertex (with special treatment for a vertex at infinity; I skip details). Then the triangulation can be laid out on the plane, and projected back stereographically to the sphere. In this manner, we got good approximations of where the feet should be. Now we run Newton's method on the feet positions, using as variables the lifted-feet positions. This is the external program "hsolve". It is assumed that the down-feet contain 0 and infinity, so that the rational map we are looking for is of the form f(z) = const*prod((z-c_i)^{d_i}) for known integers d_i. The c_i are the lifted-feet above 0 and infinity, and the equations in Newton's method say that the log-derivative of f must vanish at appropriate lifted-feet, and that f must map these lifted-feet to the down-feet. (d) For Thurston's algorithm, one starts by an arbitrary marked sphere (I chose its feet on the real axis, at equal small angles); computes a rational map using (c), computes [*] its biset using (b), and matches the original biset with the lifted one. This tells us which feet of the lifted biset we should keep. One then computes a normalized position for the sub-marked sphere: its last foot is at infinity, another one (chosen cleverly) is on the positive real axis, and the center of mass of all feet (in R^3) is (0,0,0). This is much more stable, numerically, than putting 3 points at 0,1,infty. One has a Moebius transformation that puts the sub-marked sphere in normalized position, and by (b) computes its biset. One then composes the bisets, and compares it again to the original biset to determine the marking of the edges of the new marked sphere by group elements. Then, one searches for all quadruples with large cross-ratio, and computes group-theoretically the curve separating the post-critical set in two parts that are well separated. One saturates the resulting curve into an invariant multicurve (aborting if there is an intersection between lifts), computes the Thurston matrix, and finds out (again algebraically) if there is an eigenvalue \geq 1. There is no parameter in this part of the code, all quadruples are examined; this is a weakness of the current implementation, sometimes most of the computational time is spent on searching for obstructions when it's "clear" there are none. The distance between two marked spheres (marked by the same group) is computed as follows: if their feet are close in the sense that the sum of the spherical distances between them is less that @IMG.fast, then wiggle one of the spiders to make its feet match that of the other; and check that the identity map gives, by (b), the identity biset. In that case, the sum of the feet distances is the distance between the spheres. Otherwise, add to it some formula involving the entries in the biset, which gives large integer distances. The Thurston algorithm stops when an obstruction is found or when the marked sphere moved less than @IMG.ratprec. Inside the main iteration of the algorithm, if the spider moved less that @IMG.fast, then skip step [*], and try guessing which of the lifts should be kept. Check the guess: if it is incorrect, go back to the usual method. This is useful if the biset has low degree but high post-critical set size, and useless if the biset has high degree and low post-critical set size, but I haven't taken care to disable it in that case (yet). Another speedup which I should implement, but haven't gotten to, is in (c) to remember the previously computed rational map and/or triangulated sphere, and to directly try Newton's method without doing the "layout" part. ..... DeclareCategory("IsSphereTriangulation", IsObject); BindGlobal("TRIANGULATION_FAMILY", NewFamily("SphereTriangulations", IsSphereTriangulation)); BindGlobal("TYPE_TRIANGULATION", NewType(TRIANGULATION_FAMILY, IsSphereTriangulation)); DeclareRepresentation("IsTriangulationObjectRep", IsComponentObjectRep and IsAttributeStoringRep,[]); DeclareCategory("IsTriangulationObject",IsTriangulationObjectRep); DeclareCategory("IsTriangulationVertex",IsTriangulationObject); DeclareCategory("IsTriangulationEdge",IsTriangulationObject); DeclareCategory("IsTriangulationFace",IsTriangulationObject); BindGlobal("TRIANGULATIONOBJECT_FAMILY", NewFamily("TriangulationFamily",IsTriangulationObject,CanEasilySortElements,CanEasilySortElements)); BindGlobal("TYPE_VERTEX", NewType(TRIANGULATIONOBJECT_FAMILY,IsTriangulationVertex)); BindGlobal("TYPE_EDGE", NewType(TRIANGULATIONOBJECT_FAMILY,IsTriangulationEdge)); BindGlobal("TYPE_FACE", NewType(TRIANGULATIONOBJECT_FAMILY,IsTriangulationFace)); DeclareAttribute("Neighbour", IsTriangulationVertex); DeclareOperation("Neighbours", [IsTriangulationVertex]); DeclareOperation("Neighbours", [IsTriangulationVertex,IsTriangulationEdge]); DeclareOperation("Valency", [IsTriangulationVertex]); DeclareAttribute("Pos", IsTriangulationVertex); DeclareOperation("ClosestFace", [IsTriangulationObject]); DeclareOperation("ClosestFaces", [IsTriangulationObject]); DeclareOperation("ClosestVertex", [IsTriangulationObject]); DeclareOperation("ClosestVertices", [IsTriangulationObject]); DeclareProperty("IsFake", IsTriangulationVertex); DeclareAttribute("Left", IsTriangulationEdge); DeclareAttribute("Right", IsTriangulationEdge); DeclareAttribute("To", IsTriangulationEdge); DeclareAttribute("From", IsTriangulationEdge); DeclareAttribute("Next", IsTriangulationEdge); DeclareAttribute("Prevopp", IsTriangulationEdge); DeclareAttribute("Opposite", IsTriangulationEdge); DeclareAttribute("Pos", IsTriangulationEdge); DeclareAttribute("FromPos", IsTriangulationEdge); DeclareAttribute("ToPos", IsTriangulationEdge); DeclareAttribute("Length", IsTriangulationEdge); DeclareAttribute("Map", IsTriangulationEdge); DeclareAttribute("GroupElement", IsTriangulationEdge, "mutable"); DeclareAttribute("Neighbour", IsTriangulationFace); DeclareOperation("Neighbours", [IsTriangulationFace]); DeclareOperation("Neighbours", [IsTriangulationFace,IsTriangulationEdge]); DeclareAttribute("Pos", IsTriangulationFace); DeclareAttribute("Radius", IsTriangulationFace); DeclareAttribute("Centre", IsTriangulationFace); DeclareOperation("Valency", [IsTriangulationFace]); DeclareOperation("Draw", [IsSphereTriangulation]);</p>

<p><a id="X81727B8B7A599605" name="X81727B8B7A599605"></a></p>

<h5>3.2-1 IsSphereTriangulation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsSphereTriangulation</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>The category of triangulated spheres (points in Moduli space).</p>

<p>This triangulation is a collection of vertices, edges and faces. These are new GAP objects. The attributes for vertices are:</p>


<dl>
<dt><strong class="Mark"><code class="code">Neighbour</code></strong></dt>
<dd><p>any edge starting at the vertex</p>

</dd>
<dt><strong class="Mark"><code class="code">Neighbours</code></strong></dt>
<dd><p>a list of neighbours, in counterclockwise order (an optional adugument lets one specify the starting edge)</p>

</dd>
<dt><strong class="Mark"><code class="code">Valency</code></strong></dt>
<dd><p>the number of neighbours</p>

</dd>
<dt><strong class="Mark"><code class="code">Pos</code></strong></dt>
<dd><p>The P1 point where the vertex is located</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestVertex</code></strong></dt>
<dd><p>The vertex itself</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestVertices</code></strong></dt>
<dd><p>A list containing the vertex itself</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestFace</code></strong></dt>
<dd><p>The face left of the first neighbour</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestFaces</code></strong></dt>
<dd><p>The faces that contain the vertex</p>

</dd>
<dt><strong class="Mark"><code class="code">IsFake</code></strong></dt>
<dd><p>whether the vertex was added for refinement</p>

</dd>
</dl>
<p>The edges come in opposite pairs, and are thought of as having a face on their left. Their possible attributes are:</p>


<dl>
<dt><strong class="Mark"><code class="code">Left</code>, <code class="code">Right</code></strong></dt>
<dd><p>The adjacent faces</p>

</dd>
<dt><strong class="Mark"><code class="code">To</code>, <code class="code">From</code></strong></dt>
<dd><p>The vertices that the edge goes to/from</p>

</dd>
<dt><strong class="Mark"><code class="code">Next</code></strong></dt>
<dd><p>The edge after on the left face (starting where the present edge ends)</p>

</dd>
<dt><strong class="Mark"><code class="code">Prevopp</code></strong></dt>
<dd><p>The opposite of the edge before on the left face (starting where the present edge starts)</p>

</dd>
<dt><strong class="Mark"><code class="code">Opposite</code></strong></dt>
<dd><p>The opposite edge (with reversed orientation)</p>

</dd>
<dt><strong class="Mark"><code class="code">Pos</code></strong></dt>
<dd><p>The position of the midpoint. <code class="code">FromPos</code> and <code class="code">ToPos</code> are shortcuts</p>

</dd>
<dt><strong class="Mark"><code class="code">Length</code></strong></dt>
<dt><strong class="Mark"><code class="code">Map</code></strong></dt>
<dd><p>A P1 map sending <span class="SimpleMath">[0,1]</span> to the edge</p>

</dd>
<dt><strong class="Mark"><code class="code">GroupElement</code></strong></dt>
<dd><p>A group element describing "crossing through the edge from the left to the right"</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestVertex</code></strong></dt>
<dd><p>The from vertex</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestVertices</code></strong></dt>
<dd><p>The two endpoints</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestFace</code></strong></dt>
<dd><p>The left neighbour</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestFaces</code></strong></dt>
<dd><p>The two adjacent faces</p>

</dd>
</dl>
<p>The faces have the following possible attributes:</p>


<dl>
<dt><strong class="Mark"><code class="code">Neighbour</code></strong></dt>
<dd><p>Some edge with this face on its left</p>

</dd>
<dt><strong class="Mark"><code class="code">Neighbours</code></strong></dt>
<dd><p>The neighbours of the face, in counterclockwise order around the face (an optional argument lets one specify the starting edge)</p>

</dd>
<dt><strong class="Mark"><code class="code">Pos</code></strong></dt>
<dd><p>The position of the face's barycentre</p>

</dd>
<dt><strong class="Mark"><code class="code">Radius</code>, <code class="code">Centre</code></strong></dt>
<dd><p>The circumradius and circumcentre of the face (assumed to be a triangle)</p>

</dd>
<dt><strong class="Mark"><code class="code">Valency</code></strong></dt>
<dd><p>The number of neighbouring edges</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestVertex</code></strong></dt>
<dd><p>The from of the first neighbour</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestVertices</code></strong></dt>
<dd><p>The vertices that the face contains</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestFace</code></strong></dt>
<dd><p>The face itself</p>

</dd>
<dt><strong class="Mark"><code class="code">ClosestFaces</code></strong></dt>
<dd><p>A list containing the face itself</p>

</dd>
</dl>
<p>A triangulation may be plotted with <code class="code">Draw</code>; this requires <strong class="pkg">appletviewer</strong> to be installed. The command <code class="code">Draw(t:detach)</code> detaches the subprocess after it is started. The extra arguments <code class="code">Draw(t:lower)</code> or <code class="code">Draw(t:upper)</code> stretch the triangulation to the lower, respectively upper, hemisphere.</p>

<p>DeclareOperation("EdgePath", [IsSphereTriangulation,IsTriangulationFace,IsTriangulationFace]);</p>

<p><a id="X833BA8217E601451" name="X833BA8217E601451"></a></p>

<h5>3.2-2 EdgePath</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EdgePath</code>( <var class="Arg">t</var>, <var class="Arg">f0</var>, <var class="Arg">f1</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sequence of edges taking <var class="Arg">f0</var> to <var class="Arg">f1</var>.</p>

<p>DeclareOperation("DelaunayTriangulation", [IsList]); DeclareOperation("DelaunayTriangulation", [IsList, IsFloat]);</p>

<p><a id="X80C530E87B7FA7C4" name="X80C530E87B7FA7C4"></a></p>

<h5>3.2-3 DelaunayTriangulation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DelaunayTriangulation</code>( <var class="Arg">points</var>[, <var class="Arg">quality</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A Delaunay triangulation of the sphere.</p>

<p>If <var class="Arg">points</var> is a list of points on the unit sphere, represented by their 3D coordinates, this function creates a triangulation of the sphere with these points as vertices. This triangulation satisfies the <em>Delaunay</em> condition that no point lies in the circumcircle of any face.</p>

<p>If all points are aligned on a great circle, or if all points are in a hemisphere, some points are added so as to make the triangulation simplicial with all edges of length <span class="SimpleMath">&lt;π</span>. These vertices additionally have the <code class="code">IsFake</code> property set to <code class="keyw">true</code>.</p>

<p>If the second argument <var class="Arg">quality</var>, which must be a floatean, is present, then all triangles in the resulting triangulation are guaranteed to have circumcircle ratio / minimal edge length at most <var class="Arg">quality</var>. Of course, additional vertices may need to be added to ensure that.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">octagon := Concatenation(IdentityMat(3),-IdentityMat(3))*1.0;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dt := DelaunayTriangulation(octagon);</span>
&lt;triangulation with 6 vertices, 24 edges and 8 faces&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dt!.v;</span>
[ &lt;vertex 1&gt;, &lt;vertex 2&gt;, &lt;vertex 3&gt;, &lt;vertex 4&gt;, &lt;vertex 5&gt;, &lt;vertex 6&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last[1].n;</span>
[ &lt;edge 17&gt;, &lt;edge 1&gt;, &lt;edge 2&gt;, &lt;edge 11&gt; ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">last[1].from;</span>
&lt;vertex 1&gt;
</pre></div>

<p>DeclareOperation("AddToTriangulation", [IsSphereTriangulation,IsP1Point]); DeclareOperation("AddToTriangulation", [IsSphereTriangulation,IsP1Point,IsBool]); DeclareOperation("AddToTriangulation", [IsSphereTriangulation,IsTriangulationFace,IsP1Point]); DeclareOperation("AddToTriangulation", [IsSphereTriangulation,IsTriangulationFace,IsP1Point,IsBool]);</p>

<p><a id="X82EB5B207B2C273E" name="X82EB5B207B2C273E"></a></p>

<h5>3.2-4 AddToTriangulation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AddToTriangulation</code>( <var class="Arg">t</var>[, <var class="Arg">seed</var>], <var class="Arg">point</var>[, <var class="Arg">delaunay</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This command adds the P1 point <var class="Arg">point</var> to the triangulation <var class="Arg">t</var>. If a face <var class="Arg">seed</var> is provided, it will speed up the search for the triangle in which the point is to be added. The other optional boolean argument <var class="Arg">delaunay</var> specifies whether the Delaunay condition is to be fulfilled (by flipping diagonals of some quadrilaterals made of two neighbouring triangles) after the addition.</p>

<p>DeclareOperation("RemoveFromTriangulation", [IsSphereTriangulation,IsTriangulationVertex]);</p>

<p><a id="X7A92BCE987775667" name="X7A92BCE987775667"></a></p>

<h5>3.2-5 RemoveFromTriangulation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RemoveFromTriangulation</code>( <var class="Arg">t</var>, <var class="Arg">vertex</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This command removes the vertex <var class="Arg">vertex</var> from the triangulation <var class="Arg">t</var>.</p>

<p>DeclareOperation("LocateFaceInTriangulation", [IsSphereTriangulation,IsP1Point]); DeclareOperation("LocateFaceInTriangulation", [IsSphereTriangulation,IsObject,IsP1Point]); DeclareOperation("LocateInTriangulation", [IsSphereTriangulation,IsP1Point]); DeclareOperation("LocateInTriangulation", [IsSphereTriangulation,IsObject,IsP1Point]);</p>

<p><a id="X866712E5799237C6" name="X866712E5799237C6"></a></p>

<h5>3.2-6 LocateFaceInTriangulation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LocateFaceInTriangulation</code>( <var class="Arg">t</var>[, <var class="Arg">seed</var>], <var class="Arg">point</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LocateInTriangulation</code>( <var class="Arg">t</var>[, <var class="Arg">seed</var>], <var class="Arg">point</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The face(t) in <var class="Arg">t</var> containing <var class="Arg">point</var>.</p>

<p>This command locates the face in <var class="Arg">t</var> that contains <var class="Arg">point</var>; in the second form, if <var class="Arg">point</var> lies on an edge or a vertex, it returns that edge or vertex.</p>

<p>The optional second argument specifies a starting vertex, edge, face, or vertex index from which to start the search. Its only effect is to speed up the algorithm.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">cube := Tuples([-1,1],3)/Sqrt(3.0);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">dt := DelaunayTriangulation(cube);</span>
&lt;triangulation with 8 vertices, 36 edges and 12 faces&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LocateInTriangulation(dt,dt!.v[1].pos);</span>
&lt;vertex 1&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">LocateInTriangulation(dt,[3/5,0,4/5]*1.0);</span>
&lt;face 9&gt;
</pre></div>

<p>DeclareOperation("WiggledTriangulation", [IsSphereTriangulation,IsObject]);</p>

<p><a id="X7FA533EF78FF292B" name="X7FA533EF78FF292B"></a></p>

<h5>3.2-7 WiggledTriangulation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WiggledTriangulation</code>( <var class="Arg">t</var>, <var class="Arg">moebiusmap</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WiggledTriangulation</code>( <var class="Arg">t</var>, <var class="Arg">newpoints</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A new triangulation, with moved vertices.</p>

<p>This command creates a new triangulation, in which only the P1 coordinates are changed. If the second argument <var class="Arg">moebiusmap</var> is a Möbius transformation, then it is applied to the vertices and barycentres of faces and edges. If the second argument <var class="Arg">newpoints</var> is a list of P1 points, then they are taken as new coordinates of the vertices.</p>

<p>DeclareGlobalFunction("EquidistributedP1Points");</p>

<p><a id="X852EDAD3787E522D" name="X852EDAD3787E522D"></a></p>

<h5>3.2-8 EquidistributedP1Points</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; EquidistributedP1Points</code>( <var class="Arg">N</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: A list of <var class="Arg">N</var> P1 points that are reasonably well spaced.</p>

<p>DeclareCategory("IsMarkedSphere", IsObject); BindGlobal("MARKEDSPHERES_FAMILY", NewFamily("MarkedSpheres", IsMarkedSphere)); BindGlobal("TYPE_MARKEDSPHERE", NewType(MARKEDSPHERES_FAMILY, IsMarkedSphere)); DeclareAttribute("MarkedSphere", IsSphereMachine); DeclareAttribute("MarkedSphere", IsP1Map); undocumented for now DeclareAttribute("VerticesOfMarkedSphere", IsMarkedSphere); DeclareAttribute("SpanningTreeBoundary", IsMarkedSphere);</p>

<p><a id="X7BCBD3A47B95CB12" name="X7BCBD3A47B95CB12"></a></p>

<h5>3.2-9 IsMarkedSphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; IsMarkedSphere</code></td><td class="tdright">( filter )</td></tr></table></div>
<p>The category of marked, triangulated spheres (points in Teichmüller space).</p>

<p>DeclareOperation("NewMarkedSphere", [IsP1PointCollection,IsSphereGroup]); DeclareOperation("NewMarkedSphere", [IsP1PointCollection]);</p>

<p><a id="X859AFCB184D66E76" name="X859AFCB184D66E76"></a></p>

<h5>3.2-10 NewMarkedSphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; NewMarkedSphere</code>( <var class="Arg">points</var>[, <var class="Arg">group</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A new marked sphere on points <var class="Arg">points</var>.</p>

<p>This function creates a new marked sphere, based on the Delaunay triangulation on <var class="Arg">points</var>. If a sphere group <var class="Arg">group</var> is specified, it is used to mark the sphere; otherwise a new sphere group is created.</p>

<p>DeclareOperation("Draw", [IsMarkedSphere]);</p>

<p><a id="X8563CADF7AA37AA4" name="X8563CADF7AA37AA4"></a></p>

<h5>3.2-11 Draw</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; Draw</code>( <var class="Arg">s</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>This command plots the marked sphere <var class="Arg">s</var> in a separate window. It displays the complex sphere, big dots at the post-critical set (feet of the spider), and the arcs and dual arcs of the triangulation connecting the feet.</p>

<p>If the option <code class="keyw">julia:=&lt;gridsize&gt;</code> (if no grid size is specified, it is 500 by default), then the Julia set of the map associated with the spider is also displayed. Points attracted to attracting cycles are coloured in pastel tones, and unattracted points are coloured black.</p>

<p>If the option <code class="keyw">noarcs</code> is specified, the printing of the arcs and dual arcs is disabled.</p>

<p>The options <code class="keyw">upper</code>, <code class="keyw">lower</code> and <code class="keyw">detach</code> also apply.</p>

<p>DeclareOperation("WiggledMarkedSphere", [IsMarkedSphere,IsObject]);</p>

<p><a id="X7B3ACCDC81180337" name="X7B3ACCDC81180337"></a></p>

<h5>3.2-12 WiggledMarkedSphere</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; WiggledMarkedSphere</code>( <var class="Arg">sphere</var>, <var class="Arg">m</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A new marked sphere.</p>

<p>This operation moves the vertices of the marked sphere <var class="Arg">sphere</var>, preserving its marking. The argument <var class="Arg">m</var>, which specifies a movement of the vertices, is either a Möbius transformation (to be applied to all vertices) or a list of new positions for them.</p>

<p>DeclareOperation("SphereMachineOfBranchedCovering", [IsMarkedSphere,IsMarkedSphere,IsP1Map,IsBool]); DeclareOperation("SphereMachineOfBranchedCovering", [IsMarkedSphere,IsMarkedSphere,IsP1Map]); DeclareOperation("SphereMachineAndSphereOfBranchedCovering", [IsMarkedSphere,IsP1Map,IsBool]); DeclareOperation("SphereMachineAndSphereOfBranchedCovering", [IsMarkedSphere,IsP1Map]);</p>

<p><a id="X7F86A9607DBDD8A9" name="X7F86A9607DBDD8A9"></a></p>

<h5>3.2-13 SphereMachineOfBranchedCovering</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SphereMachineOfBranchedCovering</code>( <var class="Arg">down</var>, <var class="Arg">up</var>, <var class="Arg">map</var>[, <var class="Arg">poly</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SphereMachineAndSphereOfBranchedCovering</code>( <var class="Arg">down</var>, <var class="Arg">map</var>[, <var class="Arg">poly</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere machine or [machine,marked sphere].</p>

<p>The first function computes, out of a marked sphere <var class="Arg">down</var> in the range of the P1 map <var class="Arg">map</var> and a marked sphere <var class="Arg">up</var> in its domain, the sphere machine representing the monodromy action of the map. Its input stateset is the model group of <var class="Arg">down</var>, while its output stateset is the model group of <var class="Arg">up</var>.</p>

<p>The second function first computes a marked sphere on the full preimage by <var class="Arg">map</var> of the vertices of <var class="Arg">down</var>, then computes the sphere machine, and finally returns a list containing the machine and the sphere at the source of <var class="Arg">map</var>.</p>

<p>The optional parameter <var class="Arg">poly</var> specifies that the map <var class="Arg">map</var> is to be treated as a polynomial, and that the machine is to be normalized so that its last generator is an adding machine in standard form.</p>

<p>DeclareOperation("MonodromyOfP1Map", [IsMarkedSphere,IsP1Map]); DeclareOperation("MonodromyOfP1Map", [IsP1PointCollection,IsP1Map]); DeclareOperation("MonodromyOfP1Map", [IsP1Map]);</p>

<p><a id="X7E3708BD7AFB94A4" name="X7E3708BD7AFB94A4"></a></p>

<h5>3.2-14 MonodromyOfP1Map</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; MonodromyOfP1Map</code>( [<var class="Arg">marking</var>, ]<var class="Arg">map</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The monodromy action of <var class="Arg">map</var>.</p>

<p>This function computes the monodromy of the P1 map <var class="Arg">map</var>; this is simply the activity of the sphere machine associated with the map.</p>

<p>The optional first argument <var class="Arg">marking</var> may be a marked sphere, in which case the monodromy is returned as a homomorphism from the marked sphere's marking. It may also be a list of P1 points, in which case the monodromy is returned as a list of permutations, one per point. If the first argument is missing, it is assumed to be the list of critical values of <var class="Arg">map</var>.</p>

<p>DeclareAttribute("SphereMachine", IsP1Map);</p>

<p><a id="X801927327E45A69D" name="X801927327E45A69D"></a></p>

<h5>3.2-15 SphereMachine</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; SphereMachine</code>( <var class="Arg">f</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A sphere machine.</p>

<p>This function computes a triangulation of the sphere, on the post-critical set of <var class="Arg">f</var>, and lifts it through the map <var class="Arg">f</var>. the action of the fundamental group of the punctured sphere is then read into an sphere machine <code class="code">m</code>, which is returned.</p>

<p>This machine has a preset attribute <code class="code">MarkedSphere(m)</code>.</p>

<p>An approximation of the Julia set of <var class="Arg">f</var> can be computed, and plotted on the spider, with the form <code class="code">IMGMachine(f:julia)</code> or <code class="code">IMGMachine(f:julia:=gridsize)</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">SphereMachine(P1z^2-1);</span>
&lt;FR machine with alphabet [ 1, 2 ] on Group( [ f1, f2, f3 ] )/[ f2*f1*f3 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(last);</span>
 G  |            1        2
----+---------------+--------+
 f1 |          f2,2   &lt;id&gt;,1
 f2 | f3^-1*f1*f3,1   &lt;id&gt;,2
 f3 |        &lt;id&gt;,2     f3,1
----+---------------+--------+
Relator: f2*f1*f3
</pre></div>

<p>DeclareOperation("DistanceMarkedSpheres", [IsMarkedSphere, IsMarkedSphere]); DeclareOperation("DistanceMarkedSpheres", [IsMarkedSphere, IsMarkedSphere, IsBool]);</p>

<p><a id="X860A9B5E7BC8640D" name="X860A9B5E7BC8640D"></a></p>

<h5>3.2-16 DistanceMarkedSpheres</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DistanceMarkedSpheres</code>( <var class="Arg">sphere1</var>, <var class="Arg">sphere2</var>[, <var class="Arg">fast</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: The approximate distance between the marked spheres.</p>

<p>This function approximates coarsely the Teichmüller distance between marked spheres with same model group. If the vertices of <var class="Arg">sphere1</var> can be wiggled to the vertices of <var class="Arg">sphere2</var> in such a manner that the markings coincide, then the distance is the sum of the movements of the vertices. Otherwise, it is <span class="SimpleMath">1+</span> the sum of the lengths of the images of a sphere group automorphism that carries the marking of <var class="Arg">sphere1</var> to that of <var class="Arg">sphere2</var>.</p>

<p>DeclareOperation("LiftOfConjugacyClass", [IsGroupFRMachine,IsConjugacyClassGroupRep]);</p>

<p><a id="X8692875A793FB66F" name="X8692875A793FB66F"></a></p>

<h5>3.2-17 LiftOfConjugacyClass</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; LiftOfConjugacyClass</code>( <var class="Arg">m</var>, <var class="Arg">c</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A list of conjugacy classes and multiplicities.</p>

<p>This command computes the preimage of the conjugacy class <var class="Arg">c</var> by the sphere machine <var class="Arg">m</var>, namely, it applies the wreath recursion to a representative of <var class="Arg">c</var> and collects the products on all cycles. It returns then a list of pairs <code class="code">[cc,len]</code> where <code class="code">cc</code> is the conjugacy class of a product on a cycle, and <code class="code">len</code> is the length of the cycle.</p>

<p>DeclareAttribute("ComplexConjugate", IsFRMachine); # already declared for arithmetic objects</p>

<p><a id="X7BE001A0811CD599" name="X7BE001A0811CD599"></a></p>

<h5>3.2-18 ComplexConjugate</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ComplexConjugate</code>( <var class="Arg">m</var> )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: An FR machine with inverted states.</p>

<p>This function constructs an FR machine whose generating states are the inverses of the original states. If <var class="Arg">m</var> came from a complex rational map <span class="SimpleMath">f(z)</span>, this would construct the machine of the conjugate map <span class="SimpleMath">overlinef(overline z)</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PolynomialSphereMachine(2,[1/7]);</span>
&lt;FR machine with alphabet [ 1, 2 ] and adder FRElement(...,f4) on &lt;object&gt;/[ f4*f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(a);</span>
 G  |            1            2
----+---------------+------------+
 f1 | f1^-1*f2^-1,2   f3*f2*f1,1
 f2 |          f1,1       &lt;id&gt;,2
 f3 |          f2,1       &lt;id&gt;,2
 f4 |          f4,2       &lt;id&gt;,1
----+---------------+------------+
Adding element: FRElement(...,f4)
Relator: f4*f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(ComplexConjugate(a));</span>
 G  |            1                     2
----+---------------+---------------------+
 f1 | f1*f2*f3*f4,2   f4^-1*f2^-1*f1^-1,1
 f2 |          f1,1      &lt;identity ...&gt;,2
 f3 |          f2,1      &lt;identity ...&gt;,2
 f4 |          f4,2      &lt;identity ...&gt;,1
----+---------------+---------------------+
Adding element: FRElement(...,f4)
Relator: f1*f2*f3*f4
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(a);</span>
{2/7}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(ComplexConjugate(a));</span>
{6/7}
</pre></div>

<p>DeclareOperation("RotatedSpider", [IsPolynomialSphereMachine]); DeclareOperation("RotatedSpider", [IsPolynomialSphereMachine, IsInt]);</p>

<p><a id="X7E941D2185A1DF3B" name="X7E941D2185A1DF3B"></a></p>

<h5>3.2-19 RotatedSpider</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; RotatedSpider</code>( <var class="Arg">m</var>[, <var class="Arg">p</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A polynomial FR machine with rotated spider at infinity.</p>

<p>This function constructs an isomorphic polynomial FR machine, but with a different numbering of the spider legs at infinity. This rotation is accomplished by conjugating by <code class="code">adder^p</code>, where <code class="code">adder</code> is the adding element of <var class="Arg">m</var>, and <var class="Arg">p</var>, the rotation parameter, is <span class="SimpleMath">1</span> by default.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">a := PolynomialSphereMachine(3,[1/4]);</span>
&lt;FR machine with alphabet [ 1, 2, 3 ] and adder FRElement(...,f3) on &lt;object&gt;/[ f3*f2*f1 ]&gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(a);</span>
 G  |      1        2         3
----+---------+--------+---------+
 f1 | f1^-1,2   &lt;id&gt;,3   f2*f1,1
 f2 |    f1,1   &lt;id&gt;,2    &lt;id&gt;,3
 f3 |    f3,3   &lt;id&gt;,1    &lt;id&gt;,2
----+---------+--------+---------+
Adding element: FRElement(...,f3)
Relator: f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Display(RotatedSpider(a));</span>
 G  |     1            2               3
----+--------+------------+---------------+
 f1 | &lt;id&gt;,2   f2*f1*f3,3   f3^-1*f1^-1,1
 f2 | &lt;id&gt;,1       &lt;id&gt;,2   f3^-1*f1*f3,3
 f3 |   f3,3       &lt;id&gt;,1          &lt;id&gt;,2
----+--------+------------+---------------+
Adding element: FRElement(...,f3)
Relator: f3*f2*f1
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(a);</span>
{3/8}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">List([1..10],i-&gt;ExternalAngle(RotatedSpider(a,i)));</span>
[ {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4}, {7/8}, {1/4} ]
</pre></div>

<p>DeclareOperation("BranchedCoveringByMonodromy", [IsMarkedSphere,IsGroupHomomorphism]); DeclareOperation("BranchedCoveringByMonodromy", [IsMarkedSphere,IsGroupHomomorphism,IsRecord]);</p>

<p><a id="X7AEA7BA67950292B" name="X7AEA7BA67950292B"></a></p>

<h5>3.2-20 BranchedCoveringByMonodromy</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; BranchedCoveringByMonodromy</code>( <var class="Arg">sphere</var>, <var class="Arg">monodromy</var>[, <var class="Arg">last</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A record describing a Hurwitz map.</p>

<p>If <var class="Arg">sphere</var> is a marked sphere, marked by a group <span class="SimpleMath">G</span>, and <var class="Arg">monodromy</var> is a homomorphism from <span class="SimpleMath">G</span> to a permutation group, this function computes a rational map whose critical values are the vertices of <var class="Arg">sphere</var> and whose monodromy about these critical values is given by <var class="Arg">monodromy</var>.</p>

<p>The returned data are in a record with a field <code class="code">degree</code>, the degree of the map; two fields <code class="code">map</code> and <code class="code">post</code>, describing the desired <span class="SimpleMath">P^1</span>-map --- <code class="code">post</code> is a Möbius transformation, and the composition of <code class="code">map</code> and <code class="code">post</code> is the desired map; and lists <code class="code">zeros</code>, <code class="code">poles</code> and <code class="code">cp</code> describing the zeros, poles and critical points of the map. Each entry in these lists is a record with entries <code class="code">degree</code>, <code class="code">pos</code> and <code class="code">to</code> giving, for each point in the source of <code class="code">map</code>, the local degree and the vertex in <var class="Arg">sphere</var> it maps to.</p>

<p>If a third argument is supplied, it should be a record similar to the return value of the command. If the result is close enough to the supplied record, it will be used to speed up the calculation.</p>

<p>This function requires external programs in the subdirectory "hurwitz" to have been compiled.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># we'll construct 2d-2 points on the equator, and permutations</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># in order (1,2),...,(d-1,d),(d-1,d),...,(1,2) for these points.</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># first, the marked sphere</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">d := 20;;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">z := List([0..2*d-3], i-&gt;P1Point(Exp(i*PMCOMPLEX.constants.2IPI/(2*d-2))));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">g := SphereGroup(2*d-2);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">sphere := NewMarkedSphere(z,g);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># next, the permutation representation</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">perms := List([1..d-1],i-&gt;(i,i+1));;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Append(perms,Reversed(perms));</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">perms := GroupHomomorphismByImages(g,SymmetricGroup(d),GeneratorsOfGroup(g),perms);;</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># now compute the map</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">BranchedCoveringByMonodromy(sphere,perms);</span>
rec( cp := [ rec( degree := 2, pos := &lt;1.0022-0.0099955i&gt;, to := &lt;vertex 19[ 9, 132, 13, 125 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0022-0.0099939i&gt;, to := &lt;vertex 20[ 136, 128, 129, 11 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0039-0.0027487i&gt;, to := &lt;vertex 10[ 73, 74, 16, 82 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0006-0.0027266i&gt;, to := &lt;vertex 29[ 185, 20, 179, 21 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0045-7.772e-05i&gt;, to := &lt;vertex 9[ 24, 77, 17, 72 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.1739+0.33627i&gt;, to := &lt;vertex 2[ 31, 32, 41, 28 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0546+0.12276i&gt;, to := &lt;vertex 3[ 37, 38, 33, 46 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.026+0.061128i&gt;, to := &lt;vertex 4[ 43, 39, 52, 45 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0148+0.03305i&gt;, to := &lt;vertex 5[ 49, 44, 58, 51 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0098+0.018122i&gt;, to := &lt;vertex 6[ 55, 50, 64, 57 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0071+0.0093947i&gt;, to := &lt;vertex 7[ 61, 62, 71, 59 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0055+0.0037559i&gt;, to := &lt;vertex 8[ 67, 68, 63, 69 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0035-0.0047633i&gt;, to := &lt;vertex 11[ 79, 75, 88, 81 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0031-0.0062329i&gt;, to := &lt;vertex 12[ 85, 80, 94, 87 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0029-0.0073311i&gt;, to := &lt;vertex 13[ 91, 86, 100, 93 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0027-0.008187i&gt;, to := &lt;vertex 14[ 97, 92, 106, 99 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0026-0.008824i&gt;, to := &lt;vertex 15[ 103, 98, 112, 105 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0025-0.0092966i&gt;, to := &lt;vertex 16[ 109, 104, 118, 111 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0024-0.0096345i&gt;, to := &lt;vertex 17[ 115, 110, 124, 117 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0023-0.0098698i&gt;, to := &lt;vertex 18[ 121, 116, 122, 123 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0021-0.0098672i&gt;, to := &lt;vertex 21[ 133, 127, 142, 135 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.002-0.0096298i&gt;, to := &lt;vertex 22[ 139, 134, 148, 141 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.002-0.0092884i&gt;, to := &lt;vertex 23[ 145, 140, 154, 147 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0019-0.0088147i&gt;, to := &lt;vertex 24[ 151, 146, 160, 153 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0017-0.008166i&gt;, to := &lt;vertex 25[ 157, 152, 166, 159 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0016-0.0073244i&gt;, to := &lt;vertex 26[ 163, 158, 172, 165 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0014-0.0061985i&gt;, to := &lt;vertex 27[ 169, 164, 178, 171 ]&gt; ), 
      rec( degree := 2, pos := &lt;1.0011-0.0047031i&gt;, to := &lt;vertex 28[ 175, 170, 176, 177 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.99908+0.0038448i&gt;, to := &lt;vertex 31[ 187, 183, 196, 189 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.99759+0.0094326i&gt;, to := &lt;vertex 32[ 193, 188, 202, 195 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.99461+0.018114i&gt;, to := &lt;vertex 33[ 199, 194, 208, 201 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.98944+0.032796i&gt;, to := &lt;vertex 34[ 205, 200, 214, 207 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.9772+0.058259i&gt;, to := &lt;vertex 35[ 211, 206, 220, 213 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.94133+0.11243i&gt;, to := &lt;vertex 36[ 217, 212, 226, 219 ]&gt; ), 
      rec( degree := 2, pos := &lt;0.79629+0.23807i&gt;, to := &lt;vertex 37[ 223, 224, 225, 221 ]&gt; ), 
      rec( degree := 2, pos := &lt;1+0i&gt;, to := &lt;vertex 30[ 181, 182, 6, 190 ]&gt; ) ], degree := 20, 
  map := &lt;((-0.32271060393507572-4.3599244721894763i_z)*z^20+(3.8941736874493795+78.415744809040405\
i_z)*z^19+(-16.808157937605603-665.79436908026275i_z)*z^18+(2.6572296014719168+3545.861245383101i_z\
)*z^17+(316.57668022762243-13273.931613611372i_z)*z^16+(-1801.6631038749117+37090.818733740503i_z)*\
z^15+(5888.6033008259928-80172.972599556582i_z)*z^14+(-13500.864941314803+137069.10015838256i_z)*z^\
13+(23251.436304923012-187900.36507913063i_z)*z^12+(-31048.192131502536+208077.63047409133i_z)*z^11\
+(32639.349270133433-186578.17493860485i_z)*z^10+(-27155.791223040047+135145.40893002271i_z)*z^9+(1\
7836.343164500577-78489.005444299968i_z)*z^8+(-9153.842142530224+36053.895961137248i_z)*z^7+(3598.6\
408777659944-12810.65497539577i_z)*z^6+(-1047.541279063196+3397.470068169695i_z)*z^5+(212.906725643\
0024-633.29691376653466i_z)*z^4+(-26.989372105307872+74.040615571896637i_z)*z^3+(1.6073346640110264\
-4.0860733899027055i_z)*z^2)/(z^18+(-18.034645372692019-0.45671993287358581i_z)*z^17+(153.540499397\
49956+7.7811506405054889i_z)*z^16+(-819.9344323563339-62.384270590463998i_z)*z^15+(3077.71530771320\
75+312.59552100187739i_z)*z^14+(-8623.1225834872057-1096.4398001099003i_z)*z^13+(18689.34396825033+\
2856.8568878158458i_z)*z^12+(-32038.568184053798-5725.9186424029094i_z)*z^11+(44038.148375498437+90\
17.0162876593004i_z)*z^10+(-48898.555649389084-11295.156285052604i_z)*z^9+(43964.579894637543+11318\
.997395732025i_z)*z^8+(-31931.403449371515-9074.2344933443364i_z)*z^7+(18595.347261301522+5786.6036\
424805825i_z)*z^6+(-8565.0823844971637-2899.3353634270734i_z)*z^5+(3051.6919509143086+1117.44496422\
99487i_z)*z^4+(-811.56293104533825-319.93036282549667i_z)*z^3+(151.69784956523344+64.11787684283315\
5i_z)*z^2+(-17.785127700028404-8.0311759305108268i_z)*z+(0.98427999507354302+0.47338721325094818i_z\
))&gt;, poles := [ rec( degree := 1, pos := &lt;0.99517+0.30343i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0021+0.11512i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0028+0.05702i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0026+0.030964i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0025+0.016951i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0024+0.0085784i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0024+0.003208i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0023-0.00046905i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0023-0.0030802i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0023-0.0049913i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0023-0.0064163i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0074855i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0082954i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0089048i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0093543i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0096742i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0098869i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0099988i&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ), 
      rec( degree := 2, pos := &lt;P1infinity&gt;, to := &lt;vertex 1[ 26, 27, 1, 34 ]&gt; ) ], 
  post := &lt;((-0.91742065452766763+0.99658449300666985i_z)*z+(0.74087581626192234-1.1339948562200648\
i_z))/((-0.75451451285920013+0.96940026593933015i_z)*z+(0.75451451285920013-0.96940026593933015i_z)\
)&gt;, zeros := [ rec( degree := 1, pos := &lt;0.92957+0.28362i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;0.99173+0.11408i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;0.99985+0.056874i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0014+0.030945i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.002+0.016938i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022+0.0085785i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022+0.0032076i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.00046827i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0030802i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0049908i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.006416i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0074855i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0082953i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0089047i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0093542i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0096742i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0098869i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 1, pos := &lt;1.0022-0.0099988i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ), 
      rec( degree := 2, pos := &lt;0+0i&gt;, to := &lt;vertex 38[ 30, 3, 228, 7 ]&gt; ) ] )
</pre></div>

<p>DeclareOperation("DessinByPermutations", [IsPerm,IsPerm]); DeclareOperation("DessinByPermutations", [IsPerm,IsPerm,IsPerm]);</p>

<p><a id="X84FC673C7B104194" name="X84FC673C7B104194"></a></p>

<h5>3.2-21 DessinByPermutations</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; DessinByPermutations</code>( <var class="Arg">s0</var>, <var class="Arg">s1</var>[, <var class="Arg">sinf</var>] )</td><td class="tdright">( operation )</td></tr></table></div>
<p>Returns: A rational map (see <code class="func">BranchedCoveringByMonodromy</code> (<a href="chap3.html#X7AEA7BA67950292B"><span class="RefLink">3.2-20</span></a>)) with monodromies <var class="Arg">s,t</var>.</p>

<p>This command computes the Hurwitz map associated with the spanning tree <span class="SimpleMath">[0,1]∪[1,∞]</span>; the monodromy representation is by the permutation <var class="Arg">s0</var> at <span class="SimpleMath">0</span> and <var class="Arg">s1</var> at <span class="SimpleMath">1</span>. The optional third argument <var class="Arg">sinf</var> is the monodromy at <span class="SimpleMath">∞</span>, and must equal <span class="SimpleMath">s_0^-1s_1^-1</span>.</p>

<p>The data is returned as a record, with entries <code class="code">degree</code>, <code class="code">map</code>, <code class="code">post</code>, and lists <code class="code">poles</code>, <code class="code">zeros</code>, and <code class="code">above1</code>. Each entry in the list is a record with entries <code class="code">pos</code> and <code class="code">degree</code>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DessinByPermutations((1,2),(2,3));</span>
rec( above1 := [ rec( degree := 2, pos := &lt;1+0i&gt; ),
                 rec( degree := 1, pos := &lt;-0.5-1.808e-14i&gt; ) ],
     degree := 3, 
     map := &lt;(-1.9999999999946754+2.1696575743432764e-13i_z)*z^3+(2.9999999999946754-2.1696575743432764e-13i_z)*z^2&gt;,
     poles := [ rec( degree := 3, pos := &lt;P1infinity&gt; ) ],
     post := &lt;z&gt;, 
     zeros := [ rec( degree := 1, pos := &lt;1.5+5.4241e-14i&gt; ),
                rec( degree := 2, pos := &lt;0+0i&gt; ) ] )
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput"># the Cui example</span>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">DessinByPermutations((1,3,12,4)(5,9)(6,7)(10,13,11)(2,8),</span>
           (1,5,13,6)(7,10)(2,3)(8,11,12)(4,9),
           (1,7,11,2)(3,8)(4,5)(9,12,13)(6,10));
rec( 
  above1 := [ rec( degree := 2, pos := &lt;1.9952-0.79619i&gt; ), 
      rec( degree := 2, pos := &lt;0.43236-0.17254i&gt; ), rec( degree := 2, pos := &lt;-0.9863-0.16498i&gt; ),
      rec( degree := 3, pos := &lt;-0.12749-0.99184i&gt; ), rec( degree := 4, pos := &lt;1+0i&gt; ) ], 
  degree := 13, 
  map := &lt;((-6.9809917616400366e-12+0.13002709490708636i_z)*z^13+(-0.68172329304137969-0.8451761169\
2062078i_z)*z^12+(4.0903397584184269+0.30979932084028583i_z)*z^11+(-6.3643009040280925+7.5930410215\
99336i_z)*z^10+(-5.1732765988942884-16.738910009700096i_z)*z^9+(21.528087032174511+6.11354599010482\
5i_z)*z^8+(-15.258776392407746+13.657687016998921i_z)*z^7+(-1.6403496019814323-13.453316297094229i_\
z)*z^6+(4.4999999996894351+3.3633290741375781i_z)*z^5+(-0.99999999990279009+2.5538451239904557e-11i\
_z)*z^4)/(z^9+(-4.4999999999400613+3.3633290744267983i_z)*z^8+(1.6403496020557891-13.45331629745540\
7i_z)*z^7+(15.258776391831654+13.657687016903173i_z)*z^6+(-21.528087030670253+6.1135459892162567i_z\
)*z^5+(5.1732765986730511-16.738910007513041i_z)*z^4+(6.3643009027133139+7.593041020468557i_z)*z^3+\
(-4.0903397575324512+0.30979932067785648i_z)*z^2+(0.68172329288354727-0.8451761166966415i_z)*z+(5.0\
734454343833585e-12+0.13002709487107747i_z))&gt;, 
  poles := [ rec( degree := 2, pos := &lt;1.6127-0.49018i&gt; ), 
      rec( degree := 2, pos := &lt;0.5-0.04153i&gt; ), rec( degree := 2, pos := &lt;-0.61269-0.49018i&gt; ), 
      rec( degree := 3, pos := &lt;0.5-0.43985i&gt; ), rec( degree := 4, pos := &lt;P1infinity&gt; ) ], 
  post := &lt;-z+1._z&gt;, 
  zeros := [ rec( degree := 2, pos := &lt;1.9863-0.16498i&gt; ), 
      rec( degree := 3, pos := &lt;1.1275-0.99184i&gt; ), rec( degree := 2, pos := &lt;0.56764-0.17254i&gt; ), 
      rec( degree := 2, pos := &lt;-0.99516-0.79619i&gt; ), rec( degree := 4, pos := &lt;0+0i&gt; ) ] )
</pre></div>

<p>gap&gt; # IV.5.2 in Granboulan's PhD, the automorphism group of the Mathieu group M_22 gap&gt; autm22 := Group((1,2,3,4,5,6,7,8,9,10,11)(12,13,14,15,16,17,18,19,20,21,22), (1,9,3,2)(4,8,17,21)(5,20,19,6)(12,22,16,13)(7,18)(10,11)(14,15), (3,8)(4,20)(6,18)(7,17)(9,11)(13,15)(16,21));; gap&gt; IsomorphismGroups(DerivedSubgroup(autm22),MathieuGroup(22))&lt;&gt;fail; true gap&gt; DessinByPermutations(autm22.1,autm22.2,autm22.3); ... gap&gt; # IV.5.3 in Granboulan's PhD, the "extraterrestrial" dessin with group M_24 gap&gt; m24_ET := Group((1,2,3)(4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24), (1,7,5)(2,4,23)(3,22,8)(9,21,19)(10,18,12)(13,17,15), (1,4)(2,22)(3,7)(5,6)(8,21)(9,18)(10,11)(12,17)(13,14)(15,16)(19,20)(23,24));; gap&gt; IsomorphismGroups(m24_ET,MathieuGroup(24))&lt;&gt;fail; true gap&gt; @IMG.hurwitzmesh := 0.4;; # need finer precision gap&gt; DessinByPermutations(m24_ET.1,m24_ET.2,m24_ET.3); ...</p>

<p>DeclareAttribute("KneadingSequence", IsRat);</p>

<p><a id="X86C9E1938159FEE1" name="X86C9E1938159FEE1"></a></p>

<h5>3.2-22 KneadingSequence</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; KneadingSequence</code>( <var class="Arg">angle</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: The kneading sequence associated with <var class="Arg">angle</var>.</p>

<p>This function converts a rational angle to a kneading sequence, to describe a quadratic polynomial.</p>

<p>If <var class="Arg">angle</var> is in <span class="SimpleMath">[1/7,2/7]</span> and the option <code class="code">marked</code> is set, the kneading sequence is decorated with markings in A,B,C.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KneadingSequence(1/7);</span>
[ 1, 1 ]
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">KneadingSequence(1/5:marked);</span>
[ "A1", "B1", "B0" ]
</pre></div>

<p>DeclareGlobalFunction("AllInternalAddresses");</p>

<p><a id="X857FCD7678B12A0C" name="X857FCD7678B12A0C"></a></p>

<h5>3.2-23 AllInternalAddresses</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; AllInternalAddresses</code>( <var class="Arg">n</var> )</td><td class="tdright">( attribute )</td></tr></table></div>
<p>Returns: Internal addresses of maps with period up to <var class="Arg">n</var>.</p>

<p>This function returns internal addresses for all periodic points of period up to <var class="Arg">n</var> under angle doubling. These internal addresses describe the prominent hyperbolic components along the path from the landing point to the main cardioid in the Mandelbrot set; this is a list of length <code class="code">3k</code>, with at position <code class="code">3i+1,3i+2</code> the left and right angles, respectively, and at position <code class="code">3i+3</code> the period of that component. For example, <code class="code">[ 3/7, 4/7, 3, 1/3, 2/3, 2 ]</code> describes the airplane: a polynomial with landing angles <span class="SimpleMath">[3/7,4/7]</span> of period <span class="SimpleMath">3</span>; and such that there is a polynomial with landing angles <span class="SimpleMath">[1/3,2/3]</span> and period <span class="SimpleMath">2</span>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">AllInternalAddresses(3);</span>
[ [  ], [ [ 1/3, 2/3, 2 ] ], 
[ [ 1/7, 2/7, 3 ], [ 3/7, 4/7, 3, 1/3, 2/3, 2 ], [ 5/7, 6/7, 3 ] ] ]
</pre></div>

<p>DeclareGlobalFunction("ExternalAnglesRelation");</p>

<p><a id="X86C250907E09F399" name="X86C250907E09F399"></a></p>

<h5>3.2-24 ExternalAnglesRelation</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExternalAnglesRelation</code>( <var class="Arg">degree</var>, <var class="Arg">n</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: An equivalence relation on the rationals.</p>

<p>This function returns the equivalence relation on <code class="code">Rationals</code> identifying all pairs of external angles that land at a common point of period up to <var class="Arg">n</var> under angle multiplication by by <var class="Arg">degree</var>.</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAnglesRelation(2,3);</span>
&lt;equivalence relation on Rationals &gt;
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">EquivalenceRelationPartition(last);</span>
[ [ 1/7, 2/7 ], [ 1/3, 2/3 ], [ 3/7, 4/7 ], [ 5/7, 6/7 ] ]
</pre></div>

<p>DeclareGlobalFunction("ExternalAngle");</p>

<p><a id="X84F962AF7D553DDA" name="X84F962AF7D553DDA"></a></p>

<h5>3.2-25 ExternalAngle</h5>

<div class="func"><table class="func" width="100%"><tr><td class="tdleft"><code class="func">&#8227; ExternalAngle</code>( <var class="Arg">machine</var> )</td><td class="tdright">( function )</td></tr></table></div>
<p>Returns: The external angle identifying <var class="Arg">machine</var>.</p>

<p>In case <var class="Arg">machine</var> is the sphere machine of a unicritical polynomial, this function computes the external angle landing at the critical value. More precisely, it computes the equivalence class of that external angle under <code class="func">ExternalAnglesRelation</code> (<a href="chap3.html#X86C250907E09F399"><span class="RefLink">3.2-24</span></a>).</p>


<div class="example"><pre>
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">ExternalAngle(PolynomialSphereMachine(2,[1/7])); # the rabbit</span>
{2/7}
<span class="GAPprompt">gap&gt;</span> <span class="GAPinput">Elements(last);</span>
[ 1/7, 2/7 ]
</pre></div>


<div class="chlinkprevnextbot">&nbsp;<a href="chap0.html">[Top of Book]</a>&nbsp;  <a href="chap0.html#contents">[Contents]</a>&nbsp;  &nbsp;<a href="chap2.html">[Previous Chapter]</a>&nbsp;  &nbsp;<a href="chap4.html">[Next Chapter]</a>&nbsp;  </div>


<div class="chlinkbot"><span class="chlink1">Goto Chapter: </span><a href="chap0.html">Top</a>  <a href="chap1.html">1</a>  <a href="chap2.html">2</a>  <a href="chap3.html">3</a>  <a href="chap4.html">4</a>  <a href="chap5.html">5</a>  <a href="chap6.html">6</a>  <a href="chapBib.html">Bib</a>  <a href="chapInd.html">Ind</a>  </div>

<hr />
<p class="foot">generated by <a href="http://www.math.rwth-aachen.de/~Frank.Luebeck/GAPDoc">GAPDoc2HTML</a></p>
</body>
</html>
