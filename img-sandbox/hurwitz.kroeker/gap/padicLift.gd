#############################################################################
##
#W p-adicLift                                                  Jakob Kr√∂ker
##                                                               
##
#H   @(#)$Id$
##
#Y Copyright (C) 2012, Laurent Bartholdi
##
#############################################################################
##
##
##
##############################################################################


# Dependencies: hurwitz/utils.g, package 'Float'
#
# todo: replace some more of the 'Asserts' with error messages



######################################################## PUBLIC #############################################################
#BindGlobal("@PadicLift" , rec() ) ;
#DeclareGlobalFunction( "@PadicLift.");

BindGlobal("@PadicLift" , rec() ) ;
DeclareGlobalFunction( "@PadicLift.");
@PadicLift.Tests    := rec();
@PadicLift.Internal := rec();


######### p-adic lift

# lift a solution point mod prime to module prime^(2^numLiftDepth) (p-adic approximation)
#Parameters: ( ideal,  solutionPoint , numLiftDepth)
DeclareGlobalFunction( "PadicLift@FR" );
@PadicLift.PadicLift := PadicLift@FR;
DeclareGlobalFunction( "@PadicLift.PadicLift" );


# given an ideal and its jacobian over integers/rationals, compute next padic approximation mod p^2k for for an solution mod p^k.
# Parameters: ( ideal generators, jacobian, indeterminates, solutionApprox )
DeclareGlobalFunction( "QuadraticLiftStep@FR" );
@PadicLift.QuadraticLiftStep := QuadraticLiftStep@FR;
DeclareGlobalFunction( "@PadicLift.QuadraticLiftStep" );

# given an function to test if a point belongs to an ideal and a function which computes a jacobian for a given ideal point,
# lifts a solution point mod prime to module prime^(2^numLiftDepth) (p-adic approximation)
#Parameters: ( evaluateIdealGens, jacobianAt,  solutionPoint , numLiftDepth)
DeclareGlobalFunction( "BlackBoxPadicLift@FR" );
@PadicLift.BlackBoxPadicLift := BlackBoxPadicLift@FR;
DeclareGlobalFunction( "@PadicLift.BlackBoxPadicLift" );


# given an function to test if a point belongs to an ideal and a function which computes a jacobian for a given ideal point,
# computes next padic approximation mod p^2k for for an solution mod p^k.
# Parameters:  ( evalIdealGens, computeJacobianAt, solutionApprox )
DeclareGlobalFunction( "BlackBoxQuadraticLiftStep@FR" );    
@PadicLift.BlackBoxQuadraticLiftStep := BlackBoxQuadraticLiftStep@FR;
DeclareGlobalFunction( "@PadicLift.BlackBoxQuadraticLiftStep" );


######### compute minimal polynomials and approximate ideal points from given solution over a finite field.

# given a finite field point of an ideal compute corresponding approximate ideal points over complex numbers.
#
# Parameters:   ideal (  generated by polynomials over integers or rationals), 
#               ideal point over finite field , 
#               computation options (LiftOptions) 
#
# See also 'LiftOptions()'.
DeclareGlobalFunction( "ComputeApproxIdealPoints@FR" );
@PadicLift.ComputeApproxIdealPoints := ComputeApproxIdealPoints@FR;
DeclareGlobalFunction( "@PadicLift.ComputeApproxIdealPoints" ); # hack: to show function names when using tab completition for PadicLift 


# given a finite field point of an ideal and an unknown compute corresponding minimal polynomial for the unknown over integers.
# Parameters:  ( ideal, solution, unknown,  liftOptions )
DeclareGlobalFunction( "ComputeMinimalPolynomial@FR" );
@PadicLift.ComputeMinimalPolynomial := ComputeMinimalPolynomial@FR;
DeclareGlobalFunction( "@PadicLift.ComputeMinimalPolynomial" );


# Parameters:  ( ideal, solution, unknown, minimalPolynomialVariable, liftOptions )
# minimalPolynomialVariable: usually same as unknown. See also CreateLiftOptions.
DeclareGlobalFunction( "ComputeMinimalPolynomialEx@FR" );
@PadicLift.ComputeMinimalPolynomialEx := ComputeMinimalPolynomialEx@FR;
DeclareGlobalFunction( "@PadicLift.ComputeMinimalPolynomialEx" );


# given a finite field point of an ideal and an unknown list compute corresponding minimal polynomials for the unknowns over integers.
# Parameters:  ( solutionIdeal,  solutionPoint, unknowns,  liftOptions )
# minimalPolynomialVariable: usually same as unknown. See also CreateLiftOptions.
 DeclareGlobalFunction( "ComputeMinimalPolynomials@FR" );
@PadicLift.ComputeMinimalPolynomials := ComputeMinimalPolynomials@FR;
DeclareGlobalFunction( "@PadicLift.ComputeMinimalPolynomials" ); 

DeclareGlobalFunction( "LiftOptions@FR" );
@PadicLift.LiftOptions := LiftOptions@FR;
DeclareGlobalFunction( "@PadicLift.LiftOptions" );



########################## lift utils

DeclareProperty("IsLiftOptions", IsRecord );

# compute a compatibility matrix M where M[i][j]=k if ABS(combinedPolRoots[k] - operation( firstPolRoots[i], secondPolRoots[j] ) <  tolerance
# tolerance is adjusted depending on root values.
# Parameters: ( firstPolRoots, secondPolRoots, combinedPolRoots, operation, maxTolerance  )
DeclareGlobalFunction( "ComputeRootCompatibility@FR" );
@PadicLift.ComputeRootCompatibility := ComputeRootCompatibility@FR;
DeclareGlobalFunction( "@PadicLift.ComputeRootCompatibility" );

# Parameters: ( firstPolRoots, secondPolRoots, combinedPolRoots, operation, maxTolerance , logger )
DeclareGlobalFunction( "ComputeRootCompatibilityEx@FR" );
@PadicLift.ComputeRootCompatibilityEx := ComputeRootCompatibilityEx@FR;
DeclareGlobalFunction( "@PadicLift.ComputeRootCompatibilityEx" );


# create a wrapper object for Jenkins-Traub algorithm to compute polynomial roots
# Parameter: decimalPrecision 
DeclareGlobalFunction( "CreateJenkinsTraubWrapper@FR" );
@PadicLift.CreateJenkinsTraubWrapper := CreateJenkinsTraubWrapper@FR;
DeclareGlobalFunction( "@PadicLift.CreateJenkinsTraubWrapper" );


# compute roots using Jenkins Traub algorithm implementation
# Parameter: polynomial, decimalPrecision
DeclareGlobalFunction( "RootsByJenkinsTraub@FR" );
@PadicLift.RootsByJenkinsTraub := RootsByJenkinsTraub@FR;
DeclareGlobalFunction( "@PadicLift.RootsByJenkinsTraub" );


######################################################## PRIVATE #############################################################
@PadicLift.Internal := rec();

DeclareGlobalFunction( "CREATE_LIFT_OPTIONS@FR");
@PadicLift.Internal.CreateLiftOptions := CREATE_LIFT_OPTIONS@FR;

DeclareGlobalFunction( "CHECK_LIFT_OPTIONS@FR" );
@PadicLift.Internal.CheckLiftOptions := CHECK_LIFT_OPTIONS@FR;

# compute  scalar product for matrix rows  ( (|.|_2)^2 ) (todo: how to compute a square root?)
DeclareGlobalFunction( "ROW_NORMS@FR" );
@PadicLift.Internal.RowNorms := ROW_NORMS@FR;

# compute  scalar product  for matrix columns ( (|.|_2)^2 ) 
DeclareGlobalFunction( "COLUMN_NORMS@FR" );
@PadicLift.Internal.ColumnNorms := COLUMN_NORMS@FR;

# divide row norms by minimum value. Returns a 'NormalizedRowNorms' record.
DeclareGlobalFunction( "NORMALIZED_ROW_NORMS@FR" );
@PadicLift.Internal.NormalizedRowNormw := NORMALIZED_ROW_NORMS@FR;


DeclareGlobalFunction( "CREATE_LIFT_INFO@FR" );
@PadicLift.Internal.CreateLiftInfo := CREATE_LIFT_INFO@FR;


# Parameters: ( liftInfo1, liftInfo2 )
DeclareGlobalFunction( "MERGE_LIFT_INFO@FR" );
@PadicLift.Internal.MergeLiftInfo := MERGE_LIFT_INFO@FR;


# Parameters: (unknown, indeterminates, liftResult, currentLatticeDim )
DeclareGlobalFunction( "LLL_INPUT_FROM_LIFT@FR" );
@PadicLift.Internal.LLLInputFromLift := LLL_INPUT_FROM_LIFT@FR;

DeclareGlobalFunction( "IDEAL_POINTS_APPROXIMATION@FR" );
@PadicLift.Internal.IdealPointsApproximation := IDEAL_POINTS_APPROXIMATION@FR;

#  rename '..RootCompatibility' to '..CoordinateCompatibility' ?

# adjust tolerance for coordinate pairing.
# Postcondition: returns adustedTolerance <= to the 1/3 of the minimal distance between two roots in rootList and adustedTolerance <= maxTolerance
# Parameters: ( maxTolerance, rootList)
DeclareGlobalFunction("ADJUST_PAIRING_TOLERANCE@FR");
@PadicLift.Internal.AdjustPairingTolerance := ADJUST_PAIRING_TOLERANCE@FR;

# for a given lift try to find  the minimal polynomial in variable 'unknown' by guessing its degree (heurustic method)
# starting from an initial lattice dimension, increase it until either a solution candidate is found or stop condition is triggered.
# stop condition: either current lattice dimension > maxLatticeDimension or 
#               the minimun norm of all lattice vectors did not decrease/change in comparison to the previous one
# in case the stop conditon is triggered, proceed with next padic approximation instead.
# Parameters: (unknown, indeterminates, liftResult, nextLiftResult, reductionOpts ) 
#
# todo: something is fishy relating to the stop condition...
#
DeclareGlobalFunction( "LLL_REDUCTION_ATTEMPT@FR" );
@PadicLift.Internal.LLLReductionAttempt := LLL_REDUCTION_ATTEMPT@FR;

# convert first lattice basis vector to a polynomial. 
DeclareGlobalFunction( "LATTICE_BASIS_TO_POLYNOMIAL@FR" );
@PadicLift.Internal.LatticeBasisToPolynomial := LATTICE_BASIS_TO_POLYNOMIAL@FR;


# checks, if each row   contains at least one entry (exact=false)  or exact one entry (exact=true) 
# Parameters: (compatibiltyMatrix, exact)
DeclareGlobalFunction( "COMPATIBILITY_ROWS_VALID@FR");
 @PadicLift.Internal.CompatibilityRowsValid := COMPATIBILITY_ROWS_VALID@FR;
 
 
# computes a basic compatibility matrix with property M[i][j]=1 if firstPolRoots[i] is compatible with secondPolRoots[j]. 
# Parameters: ( firstPolRoots, secondPolRoots, combinedPolRoots, operation, opts)
# Preconditions: Size(secondPolRoots)<= Size(firstPolRoots).
# Postconditions: returns compatibility matrix if rank of matrix is maximal and each row has exact one entry. Otherwise fails
# See also: ComputeRootCompatibility(...)
DeclareGlobalFunction( "COMPUTE_HURWITZ_ROOT_COMPATIBILITY@FR" );
@PadicLift.Internal.ComputeHurwitzRootCompatibility := COMPUTE_HURWITZ_ROOT_COMPATIBILITY@FR;

# checks, if a compatibility matrix M is valid 
# (for each combined root there is a root compatibility and each row and column contains at least one entry ) 
#  M[i][j]=k if firstRootlist[i] , secondRootlist[j] and combinedRootList[k] are compatible.
# Parameters: (matrix, number of combined roots, logger )
# See also: ComputeRootCompatibility(...)
DeclareGlobalFunction( "IS_VALID_ROOT_COMPATIBILITY@FR");
@PadicLift.Internal.IsValidRootCompatibility := IS_VALID_ROOT_COMPATIBILITY@FR;

# given a finite field point of an ideal compute corresponding approximate ideal points over complex numbers.
# Parameters:  ( ideal (over integers or rationals),  ideal point over finite field , lift options )
# see also 'ComputeApproxIdealPoint@FR' .
# limitations: may run faster than the generic version 'ComputeApproxIdealPoint' , but not succeed for all cases!
DeclareGlobalFunction( "COMPUTE_APPROX_HURWITZ_IDEAL_POINTS@FR" );
@PadicLift.Internal.ComputeApproxHurwitzIdealPoints := COMPUTE_APPROX_HURWITZ_IDEAL_POINTS@FR;

#create a dummy logger function (logger interface: (loglevel, message) )
DeclareGlobalFunction( "CREATE_EMPTY_LOGGER_FKT@FR" );
@PadicLift.Internal.CreateEmptyLoggerFkt := CREATE_EMPTY_LOGGER_FKT@FR;

DeclareGlobalFunction( "CREATE_FINITE_TEST_PROBLEM@FR" );
@PadicLift.Internal.CreateFiniteTestProblem := CREATE_FINITE_TEST_PROBLEM@FR;


DeclareGlobalFunction( "CREATE_RATIONAL_TEST_PROBLEM@FR" );
@PadicLift.Internal.CreateRationalTestProblem := CREATE_RATIONAL_TEST_PROBLEM@FR;

DeclareGlobalFunction( "CREATE_SYMM_TEST_PROBLEM@FR" );
@PadicLift.Internal.CreateSymmTestProblem := CREATE_SYMM_TEST_PROBLEM@FR;



MakeImmutable(@PadicLift.Internal);
MakeImmutable(@PadicLift);


